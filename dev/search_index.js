var documenterSearchIndex = {"docs":
[{"location":"api/#List-of-functions","page":"List of functions","title":"List of functions","text":"","category":"section"},{"location":"api/#Basic","page":"List of functions","title":"Basic","text":"","category":"section"},{"location":"api/#Multilinear-algebra","page":"List of functions","title":"Multilinear algebra","text":"","category":"section"},{"location":"api/#Channels","page":"List of functions","title":"Channels","text":"","category":"section"},{"location":"api/#Entanglement","page":"List of functions","title":"Entanglement","text":"","category":"section"},{"location":"api/#Entropy","page":"List of functions","title":"Entropy","text":"","category":"section"},{"location":"api/#Incompatibility","page":"List of functions","title":"Incompatibility","text":"","category":"section"},{"location":"api/#Measurements","page":"List of functions","title":"Measurements","text":"","category":"section"},{"location":"api/#Nonlocality","page":"List of functions","title":"Nonlocality","text":"","category":"section"},{"location":"api/#Norms","page":"List of functions","title":"Norms","text":"","category":"section"},{"location":"api/#Parameterizations","page":"List of functions","title":"Parameterizations","text":"","category":"section"},{"location":"api/#Random","page":"List of functions","title":"Random","text":"","category":"section"},{"location":"api/#States","page":"List of functions","title":"States","text":"","category":"section"},{"location":"api/#Internal-functions","page":"List of functions","title":"Internal functions","text":"","category":"section"},{"location":"api/#Ket","page":"List of functions","title":"Ket","text":"Toolbox for quantum information, nonlocality, and entanglement.\n\n\n\n\n\n","category":"module"},{"location":"api/#Ket.ket","page":"List of functions","title":"Ket.ket","text":"ket([T=Bool,] i::Integer, d::Integer)\n\nProduces a ket of dimension d with nonzero element i.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.ketbra","page":"List of functions","title":"Ket.ketbra","text":"ketbra(v::AbstractVector)\n\nProduces a ketbra of vector v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.proj","page":"List of functions","title":"Ket.proj","text":"proj([T=Bool,] i::Integer, d::Integer)\n\nProduces a projector onto the basis state i in dimension d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.shift","page":"List of functions","title":"Ket.shift","text":"shift([T=ComplexF64,] d::Integer, p::Integer = 1)\n\nConstructs the shift operator X of dimension d to the power p.\n\nReference: Generalized Clifford algebra\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.clock","page":"List of functions","title":"Ket.clock","text":"clock([T=ComplexF64,] d::Integer, q::Integer = 1)\n\nConstructs the clock operator Z of dimension d to the power q.\n\nReference: Generalized Clifford algebra\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.shiftclock","page":"List of functions","title":"Ket.shiftclock","text":"shiftclock(v::AbstractVector, p::Integer, q::Integer)\n\nProduces X^p * Z^q * v, where X and Z are the shift and clock operators of dimension length(v).\n\nReference: Generalized Clifford algebra\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.pauli","page":"List of functions","title":"Ket.pauli","text":"pauli([T=ComplexF64,], ind::Vector{<:Integer})\n\nConstructs the Pauli matrices: 0 or \"I\" for the identity, 1 or \"X\" for the Pauli X operation, 2 or \"Y\" for the Pauli Y operator, and 3 or \"Z\" for the Pauli Z operator. Vectors of integers between 0 and 3 or strings of I, X, Y, Z automatically generate Kronecker products of the corresponding operators.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.gellmann","page":"List of functions","title":"Ket.gellmann","text":"gellmann([T=ComplexF64,], d::Integer = 3; coeff = √(d/2))\n\nConstructs the set G of generalized d-dimensional Gell-Mann matrices normalized such that G₁ = I and Tr(GᵢGⱼ) = d δᵢⱼ. Set coeff = 1 to obtain the generalized Gell-Mann matrices normalized such that G₁ = √(2/d) I and Tr(GᵢGⱼ) = 2 δᵢⱼ.\n\nReference: Generalizations of Pauli matrices\n\n\n\n\n\ngellmann([T=ComplexF64,], i::Integer, j::Integer, d::Integer = 3)\n\nConstructs the set i,jth Gell-Mann matrix of dimension d.\n\nReference: Generalizations of Pauli matrices\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.gellmann!","page":"List of functions","title":"Ket.gellmann!","text":"gellmann!(res::AbstractMatrix{T}, i::Integer, j::Integer, d::Integer = 3)\n\nIn-place version of gellmann.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.bloch_vector","page":"List of functions","title":"Ket.bloch_vector","text":"bloch_vector(ρ::AbstractMatrix, basis = gellmann(checksquare(ρ)))\n\nReturns the coordinates of a d × d hermitian matrix in a specified basis, by default the generalized Gell-Mann basis (see gellmann). For density matrices, the resulting vector v is such that v₁ = 1 and norm(v[2:end]) ≤ √(d-1) (with equality for pure states).\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.bloch_operator","page":"List of functions","title":"Ket.bloch_operator","text":"bloch_operator(v::AbstractVector, basis = gellmann(isqrt(length(v) + 1)))\n\nProduces the operator corresponding to the Bloch vector v.\n\nFor qubits with the default basis (Pauli operators):\n\nif v has length 3, the output is ½(I + v₁σ₁ + v₂σ₂ + v₃σ₃),\nif v has length 4, the output is ½(v₁I + v₂σ₁ + v₃σ₂ + v₄σ₃).\n\nIn general:\n\nif v has length d²-1, the output is (I+v⋅basis[2:end])/d,\nif v has lengh d², the output is v⋅basis/d.\n\nNo checks are performed on the result.\n\nReference: Eltschka et al. arXiv:2012.00587\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.cleanup!","page":"List of functions","title":"Ket.cleanup!","text":"cleanup!(M::AbstractArray{T}; tol = _eps(T))\n\nZeroes out real or imaginary parts of M that are smaller than tol.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.symmetric_projector","page":"List of functions","title":"Ket.symmetric_projector","text":"symmetric_projector(dim::Integer, n::Integer)\n\nComputes the projector onto the symmetric subspace of n copies of a dim-dimensional space.\n\nReference: Watrous' book, Sec. 7.1.1\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.symmetric_isometry","page":"List of functions","title":"Ket.symmetric_isometry","text":"symmetric_isometry(dim::Integer, n::Integer)\n\nComputes an isometry that encodes the symmetric subspace of n copies of a dim-dimensional space. Specifically, it maps a vector space of dimension binomial(n + dim -1, dim -1) onto the symmetric subspace of the symmetric subspace of the vector space of dimension dim^n.\n\nReference: Watrous' book, Sec. 7.1.1\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.orthonormal_range","page":"List of functions","title":"Ket.orthonormal_range","text":"orthonormal_range(A::AbstractMatrix{T}; tol::T=nothing) where {T<:Number}\n\nOrthonormal basis for the range of A. When A is sparse and T ∈ [Float64, ComplexF64, Float32, ComplexF32], uses a QR factorization and returns a sparse result, otherwise uses an SVD and returns a dense matrix. Tolerance tol is used to compute the rank and is automatically set if not provided.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.n_body_basis","page":"List of functions","title":"Ket.n_body_basis","text":"n_body_basis(\nn::Integer,\nn_parties::Integer;\nsb::AbstractVector{<:AbstractMatrix} = [pauli(1), pauli(2), pauli(3)],\neye::AbstractMatrix = I(size(sb[1], 1))\n\nReturn the basis of n nontrivial operators acting on n_parties, by default using sparse Pauli matrices.\n\nFor example, n_body_basis(2, 3) generates all products of two Paulis and one identity, so X  X  1 X  1  X  X  Y  1  1  Z  Z.\n\nInstead of Paulis, a basis can be provided by the parameter sb, and the identity can be changed with eye.\n\nThis function returns a generator, which can then be used e.g. in for loops without fully allocating the entire basis at once. If you need a vector, call collect on it.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.applymap_subsystem","page":"List of functions","title":"Ket.applymap_subsystem","text":"applymap_subsystem(op::AbstractMatrix, ψ::AbstractVector, subsystems::Union{Integer, AbstractVector{<:Integer}}, dims::AbstractVector = _equal_sizes(ρ))\n\nApplies the operator op to the subsytem of ρ identified by subsystems, resulting in (op ⊗ I) * ψ. If the argument dims is omitted two equally-sized subsystems are assumed.\n\n\n\n\n\napplymap_subsystem(K::AbstractVector{<:AbstractMatrix}, ρ::AbstractMatrix, subsystems::Union{Integer, AbstractVector{<:Integer}}, dims::AbstractVector = _equal_sizes(ρ))\n\nApplies the Kraus operators in K to the subsytems of ρ identified by subsystems, resulting in ∑ᵢ(K[i] ⊗ I) * ρ * (K[i]' ⊗ I). If the argument dims is omitted two equally-sized subsystems are assumed.\n\n\n\n\n\napplymap_subsystem(K::AbstractVector{<:AbstractSparseArray}, ρ::AbstractSparseArray, subsystems::Union{Integer, AbstractVector{<:Integer}}, dims::AbstractVector = _equal_sizes(ρ))\n\nApplies the sparse Kraus operators in K to the subsytems of a sparse matrix ρ identified by subsystems, resulting in ∑ᵢ(K[i] ⊗ I) * ρ * (K[i]' ⊗ I). If the argument dims is omitted two equally-sized subsystems are assumed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.partial_trace","page":"List of functions","title":"Ket.partial_trace","text":"partial_trace(X::AbstractMatrix, remove::Union{Integer, AbstractVector{<:Integer}}, dims::AbstractVector = _equal_sizes(X))\n\nTakes the partial trace of matrix X with subsystem dimensions dims over the subsystems in remove. If the argument dims is omitted two equally-sized subsystems are assumed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.partial_transpose","page":"List of functions","title":"Ket.partial_transpose","text":"partial_transpose(X::AbstractMatrix, transp::Union{Integer, AbstractVector{<:Integer}}, dims::AbstractVector = _equal_sizes(X))\n\nTakes the partial transpose of matrix X with subsystem dimensions dims over the subsystems in transp. If the argument dims is omitted two equally-sized subsystems are assumed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.permute_systems","page":"List of functions","title":"Ket.permute_systems","text":"permute_systems(X::AbstractVector, perm::AbstractVector, dims::AbstractVector = _equal_sizes(X))\n\nPermutes the order of the subsystems of vector X with subsystem dimensions dims according to the permutation perm. If the argument dims is omitted two equally-sized subsystems are assumed.\n\n\n\n\n\npermute_systems(X::AbstractMatrix, perm::AbstractVector, dims::AbstractVector = _equal_sizes(X))\n\nPermutes the order of the subsystems of the square matrix X, which is composed by square subsystems of dimensions dims, according to the permutation perm. If the argument dims is omitted two equally-sized subsystems are assumed.\n\n\n\n\n\npermute_systems(X::AbstractMatrix, perm::Vector, dims::Matrix)\n\nPermutes the order of the subsystems of the matrix X, which is composed by subsystems of dimensions dims, according to the permutation perm. dims should be a n × 2 matrix where dims[i, 1] is the number of rows of subsystem i, and dims[i, 2] is its number of columns.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.permutation_matrix","page":"List of functions","title":"Ket.permutation_matrix","text":"permutation_matrix(dims::Union{Integer,AbstractVector}, perm::AbstractVector)\n\nUnitary that permutes subsystems of dimension dims according to the permutation perm. If dims is an Integer, assumes there are length(perm) subsystems of equal dimensions dims.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.trace_replace","page":"List of functions","title":"Ket.trace_replace","text":"trace_replace(X::AbstractMatrix, replace::Union{Integer, AbstractVector{<:Integer}}, dims::AbstractVector = _equal_sizes(X))\n\nTakes the partial trace of matrix X with subsystem dimensions dims over the subsystems in replace and replace them with normalized identity. If the argument dims is omitted two equally-sized subsystems are assumed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.applymap","page":"List of functions","title":"Ket.applymap","text":"applymap(K::Vector{<:AbstractMatrix}, M::AbstractMatrix)\n\nApplies the CP map given by the Kraus operators K to the matrix M. Preserves sparsity.\n\n\n\n\n\napplymap(Φ::AbstractMatrix, M::AbstractMatrix)\n\nApplies the CP map given by the Choi-Jamiołkowski operator Φ to the matrix M. Preserves sparsity.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.applymap!","page":"List of functions","title":"Ket.applymap!","text":"applymap!(result::AbstractMatrix, K::Vector{<:AbstractMatrix}, M::AbstractMatrix, temp::AbstractMatrix)\n\nApplies the CP map given by the Kraus operators K to the matrix M without allocating or wrapping. result and temp must be matrices of size dout × dout and dout × din, where dout, din == size(K[1]).\n\n\n\n\n\n applymap!(result::AbstractMatrix, Φ::AbstractMatrix, M::AbstractMatrix)\n\nApplies the CP map given by the Choi-Jamiołkowski operator Φ to the matrix M without allocating or wrapping. In the symmetric or Hermitian cases only the upper triangular is computed. result must be a matrix of size dout × dout,  where size(M, 1) * dout == size(Φ, 1).\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.choi","page":"List of functions","title":"Ket.choi","text":"choi(K::Vector{<:AbstractMatrix})\n\nConstructs the Choi-Jamiołkowski representation of the CP map given by the Kraus operators K. Preserves sparsity. The convention used is that choi(K) = ∑ᵢⱼ |i⟩⟨j|⊗K|i⟩⟨j|K'.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.channel_bit_flip","page":"List of functions","title":"Ket.channel_bit_flip","text":"channel_bit_flip(p::Real)\n\nReturn the Kraus operator representation of the bit flip channel. It applies Pauli-X with probability 1 − p (flip from |0⟩ to |1⟩ and vice versa).\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.channel_phase_damping","page":"List of functions","title":"Ket.channel_phase_damping","text":"channel_phase_damping(λ::Real)\n\nReturn the Kraus operator representation of the phase damping channel. It describes the photon scattering or electron perturbation. 'λ' is the probability being scattered or perturbed (without loss of energy).\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.channel_phase_flip","page":"List of functions","title":"Ket.channel_phase_flip","text":"channel_phase_flip(p::Real)\n\nReturn the Kraus operator representation of the phase flip channel. It applies Pauli-Z with probability 1 − p.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.channel_amplitude_damping","page":"List of functions","title":"Ket.channel_amplitude_damping","text":"channel_amplitude_damping(γ::Real)\n\nReturn the Kraus operator representation of the amplitude damping channel. It describes the effect of dissipation to an environment at zero temperature. γ is the probability of the system to decay to the ground state.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.channel_amplitude_damping_generalized","page":"List of functions","title":"Ket.channel_amplitude_damping_generalized","text":"channel_amplitude_damping_generalized(rho::AbstractMatrix, p::Real, γ::Real)\n\nReturn the Kraus operator representation of the generalized amplitude damping channel. It describes the effect of dissipation to an environment at finite temperature. γ is the probability of the system to decay to the ground state. 1-p can be thought as the energy of the stationary state.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.channel_bit_phase_flip","page":"List of functions","title":"Ket.channel_bit_phase_flip","text":"channel_bit_phase_flip(p::Real)\n\nReturn the Kraus operator representation of the phase flip channel. It applies Pauli-Y (=iXY) with probability 1 − p.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.channel_depolarizing","page":"List of functions","title":"Ket.channel_depolarizing","text":"channel_depolarizing(v::Real, d::Integer = 2)\n\nReturn the Kraus operator representation of the depolarizing channel of dimension d. It replaces a single qudit by the completely mixed state with probability '1-v'.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.schmidt_decomposition","page":"List of functions","title":"Ket.schmidt_decomposition","text":"schmidt_decomposition(ψ::AbstractVector, dims::AbstractVector = _equal_sizes(ψ))\n\nProduces the Schmidt decomposition of ψ with subsystem dimensions dims. If the argument dims is omitted equally-sized subsystems are assumed. Returns the (sorted) Schmidt coefficients λ and isometries U, V such that kron(U', V')*ψ is of Schmidt form.\n\nReference: Schmidt decomposition\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.entanglement_entropy","page":"List of functions","title":"Ket.entanglement_entropy","text":"entanglement_entropy(ψ::AbstractVector, dims::AbstractVector = _equal_sizes(ψ); base = 2)\n\nComputes the relative entropy of entanglement of a bipartite pure state ψ with subsystem dimensions dims. If the argument dims is omitted equally-sized subsystems are assumed.\n\n\n\n\n\nentanglement_entropy(ρ::AbstractMatrix, dims::AbstractVector = _equal_sizes(ρ), n::Integer = 1; verbose = false, base = 2)\n\nLower bounds the relative entropy of entanglement of a bipartite state ρ with subsystem dimensions dims using level n of the DPS hierarchy. If the argument dims is omitted equally-sized subsystems are assumed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.entanglement_robustness","page":"List of functions","title":"Ket.entanglement_robustness","text":"entanglement_robustness(\n    ρ::AbstractMatrix{T},\n    dims::AbstractVector = _equal_sizes(ρ),\n    n::Integer = 1;\n    noise::String = \"white\"\n    ppt::Bool = true,\n    inner::Bool = false,\n    verbose::Bool = false,\n    dualize::Bool = false,\n    solver = Hypatia.Optimizer{_solver_type(T)})\n\nLower (or upper) bounds the entanglement robustness of state ρ with subsystem dimensions dims using level n of the DPS hierarchy (or inner DPS, when inner = true). Argument noise indicates the kind of noise to be used: \"white\" (default), \"separable\", or \"general\". Argument ppt indicates whether to include the partial transposition constraints. Argument dualize determines whether the dual problem is solved instead. WARNING: This is critical for performance, and the correct choice depends on the solver.\n\nReturns the robustness and a witness W (note that for inner = true, this might not be a valid entanglement witness).\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.schmidt_number","page":"List of functions","title":"Ket.schmidt_number","text":"schmidt_number(\n    ρ::AbstractMatrix{T},\n    s::Integer = 2,\n    dims::AbstractVector = _equal_sizes(ρ),\n    n::Integer = 1;\n    ppt::Bool = true,\n    verbose::Bool = false,\n    solver = Hypatia.Optimizer{_solver_type(T)})\n\nUpper bound on the white noise robustness of ρ such that it has a Schmidt number s.\n\nIf a state ρ with local dimensions d_A and d_B has Schmidt number s, then there is a PSD matrix ω in the extended space AABB, where A and B have dimension s, such that ω  s is separable  against AABB and Π^ ω Π = ρ, where Π = 1_A  s ψ^+  1_B, and ψ^+ is a non-normalized maximally entangled state. Separabiity is tested with the DPS hierarchy, with n controlling the how many copies of the BB subsystem are used.\n\nReferences:\n\nHulpke, Bruss, Lewenstein, Sanpera, arXiv:quant-ph/0401118\nWeilenmann, Dive, Trillo, Aguilar, Navascués, arXiv:1912.10056\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.ppt_mixture","page":"List of functions","title":"Ket.ppt_mixture","text":"function ppt_mixture(\n    ρ::AbstractMatrix{T},\n    dims::AbstractVector;\n    verbose::Bool = false,\n    solver = Hypatia.Optimizer{_solver_type(T)})\n\nLower bound on the white noise such that ρ is still a genuinely multipartite entangled state and a GME witness that detects ρ.\n\nThe set of GME states is approximated by the set of PPT mixtures, so the entanglement across the bipartitions is decided with the PPT criterion. If the state is a PPT mixture, returns a 0 matrix instead of a witness.\n\nReference: Jungnitsch, Moroder, Gühne, arXiv:quant-ph/0401118\n\n\n\n\n\nfunction ppt_mixture(\n    ρ::AbstractMatrix{T},\n    dims::AbstractVector,\n    obs::AbstractVector{<:AbstractMatrix} = Vector{Matrix}();\n    verbose::Bool = false,\n    solver = Hypatia.Optimizer{_solver_type(T)})\n\nLower bound on the white noise such that ρ is still a genuinely multipartite entangled state that can be detected with a witness using only the operators provided in obs, and the values of the coefficients defining such a witness.\n\nMore precisely, if a list of observables O_i is provided in the parameter obs, the witness will be of the form _i α_i O_i and detects ρ only using these observables. For example, using only two-body operators (and lower order) one can call\n\njulia> two_body_basis = collect(Iterators.flatten(n_body_basis(i, 3) for i ∈ 0:2))\njulia> ppt_mixture(state_ghz(), [2, 2, 2], two_body_basis)\n\nReference: Jungnitsch, Moroder, Gühne arXiv:quant-ph/0401118\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.entropy","page":"List of functions","title":"Ket.entropy","text":"entropy(ρ::AbstractMatrix{T}, α::real(T) = 1; base = 2)\n\nComputes the von Neumann entropy -tr(ρ log ρ) of a positive semidefinite operator ρ using a base base logarithm.\n\nIf given α != 1 computes the Rényi entropy log(tr(ρ^α)) / (1 - α).\n\nReferences:\n\nvon Neumann entropy\nRényi entropy\n\n\n\n\n\nentropy(p::AbstractVector{T}, α::T = 1; base = 2)\n\nComputes the Shannon entropy -Σᵢpᵢlog(pᵢ) of a non-negative vector p using a base base logarithm.\n\nIf α != 1 is given computes the Rényi entropy log(Σᵢpᵢ^α )/(1 - α).\n\nReferences:\n\nEntropy (information theory)\nRényi entropy\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.binary_entropy","page":"List of functions","title":"Ket.binary_entropy","text":"binary_entropy(p::T, α::T = T(1); base = 2)\n\nComputes the Shannon entropy -p log(p) - (1-p)log(1-p) of a probability p using a base base logarithm.\n\nIf α != 1 is given computes the Rényi entropy log(p^α + (1-p)^α) / (1-α).\n\nReferences:\n\nEntropy (information theory)\nRényi entropy\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.relative_entropy","page":"List of functions","title":"Ket.relative_entropy","text":"relative_entropy(ρ::AbstractMatrix{T}, σ::AbstractMatrix{T}, α::real(T) = 1; base = 2)\n\nComputes the (quantum) relative entropy tr(ρ (log ρ - log σ)) between positive semidefinite matrices ρ and σ using a base base logarithm.\n\nIf given α != 1 computes the (quantum) Rényi sandwiched relative entropy log(tr((σ^((1-α)/2α) * ρ * σ^((1-α)/2α))^α)) / (α - 1).\n\nNote that the support of ρ must be contained in the support of σ but for efficiency this is not checked.\n\nReferences:\n\nQuantum relative entropy\nRényi entropy\n\n\n\n\n\nrelative_entropy(p::AbstractVector{T}, q::AbstractVector{T}, α::T = 1; base = 2)\n\nComputes the relative entropy Σᵢpᵢlog(pᵢ/qᵢ) between two non-negative vectors p and q using a base base logarithm.\n\nIf given α != 1 computes the Rényi relative entropy log(Σᵢpᵢ^α * qᵢ^(1-α)) / (α - 1).\n\nNote that the support of p must be contained in the support of q but for efficiency this is not checked.\n\nReferences:\n\nRelative entropy\nRényi entropy\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.binary_relative_entropy","page":"List of functions","title":"Ket.binary_relative_entropy","text":"binary_relative_entropy(p::T, q::T, α::T = 1; base = 2)\n\nComputes the binary relative entropy p log(p/q) + (1-p) log((1-p)/(1-q)) between two probabilities p and q using a base base logarithm.\n\nIf given α != 1 computes the Rényi binary relative entropy log(p^α * q^(1-α) + (1-p)^α * (1-q)^α) / (α - 1).\n\nReferences:\n\nRelative entropy\nRényi entropy\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.conditional_entropy","page":"List of functions","title":"Ket.conditional_entropy","text":"conditional_entropy(pAB::AbstractMatrix{T}, α::T = 1; base = 2)\n\nComputes the conditional Shannon entropy ∑ᵢⱼpAB[i,j] * log(pAB[i|j]) of the joint probability distribution pAB using a base base logarithm.\n\nIf α != 1 is given, computes the conditional Rényi entropy log(∑ⱼpAB[j] * (∑ᵢpAB[i|j]^α)^(1/α)) * α / (1 - α).\n\nReferences:\n\nConditional entropy\nMüller-Lennert et al. arXiv:1306.3142\n\n\n\n\n\nconditional_entropy(ρ::AbstractMatrix{T}, cond::Union{Integer,AbstractVector{<:Integer}}, dims::AbstractVector, α::real(T) = 1; base = 2)\n\nComputes the conditional von Neumann entropy of ρ with subsystem dimensions dims and conditioning systems cond, using a base base logarithm.\n\nIf α != 1 is given, computes instead the following lower bound to the conditional Rényi entropy: -Dα(ρ||I ⊗ ρ_cond). It is close to the true value when α is close to 1.\n\nReferences:\n\nConditional quantum entropy\nMüller-Lennert et al. arXiv:1306.3142\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.incompatibility_robustness","page":"List of functions","title":"Ket.incompatibility_robustness","text":"incompatibility_robustness(\n    A::Vector{Measurement{<:Number}};\n    noise::String = \"general\",\n    return_parent::Bool = false,\n    verbose::Bool = false,\n    solver = Hypatia.Optimizer{_solver_type(T)})\n\nComputes the incompatibility robustness of the measurements in the vector A. Depending on the noise model chosen, the second argument can be \"depolarizing\" ({tr(Aₐ)I/d}ₐ, where d is the dimension of the system), \"random\" ({I/n}ₐ, where n is the number of outcomes), \"probabilistic\" ({pₐI}ₐ, where p is a probability distribution), \"jointly_measurable\", or \"general\" (default). Returns the parent POVM if return_parent = true.\n\nReferences:\n\nDesignolle, Farkas, Kaniewski, arXiv:1906.00448 (for the different noise models)\nGühne et al., arXiv:2112.06784 (Section III.B.2)\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.Measurement","page":"List of functions","title":"Ket.Measurement","text":"Measurement{T}\n\nAlias for Vector{Hermitian{T,Matrix{T}}}\n\n\n\n\n\n","category":"type"},{"location":"api/#Ket.sic_povm","page":"List of functions","title":"Ket.sic_povm","text":"sic_povm([T=ComplexF64,] d::Integer)\n\nConstructs a vector of d² vectors |vᵢ⟩ such that |vᵢ⟩⟨vᵢ| forms a SIC-POVM of dimension d. This construction is based on the Weyl-Heisenberg fiducial.\n\nReference: Appleby, Yadsan-Appleby, Zauner, arXiv:1209.1813\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.test_sic","page":"List of functions","title":"Ket.test_sic","text":"test_sic(vecs)\n\nChecks if vecs is a vector of d² vectors |vᵢ⟩ such that |vᵢ⟩⟨vᵢ| forms a SIC-POVM of dimension d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.test_povm","page":"List of functions","title":"Ket.test_povm","text":"test_povm(A::Vector{<:AbstractMatrix{T}})\n\nChecks if the measurement defined by A is valid (hermitian, semi-definite positive, and normalized).\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.dilate_povm","page":"List of functions","title":"Ket.dilate_povm","text":"dilate_povm(vecs::Vector{Vector{T}})\n\nDoes the Naimark dilation of a rank-1 POVM given as a vector of vectors. This is the minimal dilation.\n\n\n\n\n\ndilate_povm(E::Vector{<:AbstractMatrix})\n\nDoes the Naimark dilation of a POVM given as a vector of matrices. This always works, but is wasteful if the POVM elements are not full rank.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.povm","page":"List of functions","title":"Ket.povm","text":"povm(B::Vector{<:AbstractMatrix{T}})\n\nCreates a set of (projective) measurements from a set of bases given as unitary matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.povm_dichotomic","page":"List of functions","title":"Ket.povm_dichotomic","text":"povm_dichotomic(E::AbstractMatrix)\n\nCreates the dichotomic measurement [E, I - E].\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.mub","page":"List of functions","title":"Ket.mub","text":"mub([T=ComplexF64,] d::Integer)\n\nConstruction of the standard complete set of MUBs. The output contains 1+minᵢ pᵢ^rᵢ bases, where d = ∏ᵢ pᵢ^rᵢ.\n\nReference: Durt, Englert, Bengtsson, Życzkowski, arXiv:1004.3348\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.test_mub","page":"List of functions","title":"Ket.test_mub","text":"test_mub(B::Vector{Matrix{<:Number}})\n\nChecks if the input bases are mutually unbiased.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.discrimination_min_error","page":"List of functions","title":"Ket.discrimination_min_error","text":"discrimination_min_error(\n    ρ::Vector{<:AbstractMatrix},\n    q::Vector{<:Real} = fill(1/length(ρ), length(ρ));\n    verbose = false,\n    dualize = false,\n    solver = Hypatia.Optimizer\n)\n\nComputes the minimum-error probability of discriminating a vector of states ρ with probabilities q, along with the optimal POVM. q is assumed uniform if omitted.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.pretty_good_measurement","page":"List of functions","title":"Ket.pretty_good_measurement","text":"pretty_good_measurement(ρ::Vector{<:AbstractMatrix}, q::Vector{<:Real} = ones(length(ρ)))\n\nComputes the pretty good measurement POVM for discriminating a vector of states ρ with probabilities q. If q is omitted it is assumed uniform.\n\nReference: Watrous, Theory of Quantum Information Cp. 3\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.game_chsh","page":"List of functions","title":"Ket.game_chsh","text":"game_chsh([T=Float64,] d::Integer = 2)\n\nCHSH-d nonlocal game in probability notation. If T is an integer type the game is unnormalized.\n\nReference: Buhrman and Massar, arXiv:quant-ph/0409066\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.game_cglmp","page":"List of functions","title":"Ket.game_cglmp","text":"game_cglmp([T=Float64,] d::Integer = 3)\n\nCGLMP nonlocal game in probability notation. If T is an integer type the game is unnormalized.\n\nReferences:\n\nCollins, Gisin, Linden, Massar, Popescu, arXiv:quant-ph/0106024 (original game)\nAraújo, Hirsch, Quintino, arXiv:2005.13418 (form presented here)\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.game_braunsteincaves","page":"List of functions","title":"Ket.game_braunsteincaves","text":"game_braunsteincaves([T=Float64,] s::Integer = 3)\n\nBraunstein-Caves nonlocal game in probability notation. Known in the computer science literature as odd cycle game. If T is an integer type the game is unnormalized.\n\nReferences: Braunstein and Caves doi:10.1016/0003-4916(90)90339-P Cleve et al., arXiv:quant-ph/0404076\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.game_inn22","page":"List of functions","title":"Ket.game_inn22","text":"game_inn22([T=Float64,] n::Integer = 3)\n\ninn22 Bell functional in Collins-Gisin notation. Local bound 1.\n\nReference: Cezary Śliwa, arXiv:quant-ph/0305190\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.game_gyni","page":"List of functions","title":"Ket.game_gyni","text":"gyni([T=Float64,] n::Integer)\n\nGuess your neighbour's input nonlocal game in probability notation. If T is an integer type the game is unnormalized.\n\nReference: Almeida et al., arXiv:1003.3844\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.game_mermin","page":"List of functions","title":"Ket.game_mermin","text":"game_mermin([T=Float64,] n::Integer)\n\nGHZ-Mermin game in probability notation. Local bound 1/2 + 2^-ceil(n/2). If T is an integer type the game is unnormalized.\n\nReference: Brassard et al., arXiv:quant-ph/0408052\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.game_grandjean","page":"List of functions","title":"Ket.game_grandjean","text":"game_grandjean([T=Float64,] k::Integer)\n\nInequality (1) from Grandjean et al. in probability notation. Local bound 1 - k.\n\nReference: Grandjean et al., arXiv:1204.3829\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.local_bound","page":"List of functions","title":"Ket.local_bound","text":"local_bound(G::Array{T,N}; correlation = N < 4, marg = true)\n\nComputes the local bound of a multipartite Bell functional G given as an N-dimensional array. If correlation is false, G is assumed to be written in probability notation. If correlation is true, G is assumed to be written in correlation notation, with or without marginals depending on marg.\n\nReference: Araújo, Hirsch, Quintino, arXiv:2005.13418\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.tsirelson_bound","page":"List of functions","title":"Ket.tsirelson_bound","text":"tsirelson_bound(CG::Array, scenario::Tuple, level; verbose::Bool = false, dualize::Bool = false, solver = Hypatia.Optimizer{_solver_type(T)})\n\nUpper bounds the Tsirelson bound of a multipartite Bell funcional CG, written in Collins-Gisin notation. scenario is a tuple detailing the number of inputs and outputs, in the order (oa, ob, ..., ia, ib, ...). level is an integer or a string like \"1 + A B\" determining the level of the NPA hierarchy. verbose determines whether solver output is printed. dualize determines whether the dual problem is solved instead. WARNING: This is critical for performance, and the correct choice depends on the solver.\n\n\n\n\n\ntsirelson_bound(FC::Array, level; verbose::Bool = false, dualize::Bool = false, solver = Hypatia.Optimizer{_solver_type(T)})\n\nUpper bounds the Tsirelson bound of a multipartite Bell funcional FC, written in correlation notation. level is an integer or a string like \"1 + A B\" determining the level of the NPA hierarchy. verbose determines whether solver output is printed. dualize determines whether the dual problem is solved instead. WARNING: This is critical for performance, and the correct choice depends on the solver.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.seesaw","page":"List of functions","title":"Ket.seesaw","text":"seesaw(\n    CG::Matrix,\n    scenario::Tuple,\n    d::Integer,\n    n_trials::Integer = 1;\n    verbose::Bool = false,\n    solver = Hypatia.Optimizer{_solver_type(T)})\n\nMaximizes a bipartite Bell functional CG in Collins-Gisin notation using the seesaw heuristic. scenario is a vector detailing the number of inputs and outputs, in the order (oa, ob, ia, ib). d is an integer determining the local dimension of the strategy.\n\nReturns a tuple ω, ψ, A, B, where ω is the maximum found, ψ the state, and A,B Alice and Bob's vectors of POVMs.\n\nIf oa = ob = 2 the heuristic reduces to a bunch of eigenvalue problems. Otherwise semidefinite programming is needed and we use the assemblage version of seesaw.\n\nThe heuristic is executed n_trials times, and the best result is returned.\n\nReferences:\n\nPál and Vértesi, arXiv:1006.3032\nTavakoli et al., arXiv:2307.02551 (Sec. II.B.1)\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.tensor_probability","page":"List of functions","title":"Ket.tensor_probability","text":"tensor_probability(CG::Array, scenario::Tuple, behaviour::Bool = false)\n\nTakes a multipartite Bell functional CG in Collins-Gisin notation and transforms it to probability notation. scenario is a tuple detailing the number of inputs and outputs, in the order (oa, ob, ..., ia, ib, ...). If behaviour is true do instead the transformation for behaviours. Doesn't assume normalization.\n\n\n\n\n\ntensor_probability(FC::Matrix, behaviour::Bool = false)\n\nTakes a bipartite Bell functional FC in correlation notation and transforms it to probability notation. If behaviour is true do instead the transformation for behaviours. Doesn't assume normalization.\n\n\n\n\n\ntensor_probability(rho::Hermitian, all_Aax::Vector{Measurement}...)\ntensor_probability(rho::Hermitian, Aax::Vector{Measurement}, N::Integer)\n\nApplies N sets of measurements onto a state rho to form a probability array. If all parties apply the same measurements, use the shorthand notation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.tensor_collinsgisin","page":"List of functions","title":"Ket.tensor_collinsgisin","text":"tensor_collinsgisin(p::Array, behaviour::Bool = false; correlation::Bool = false)\n\nConverts a multipartite Bell functional p into Collins-Gisin notation, with marginals in the first index of each dimension. If correlation is true, p is assumed to be written in correlation notation. Otherwise, p is assumed to be written in probability notation. If behaviour is true do instead the transformation for behaviours. Doesn't assume normalization.\n\nAlso accepts the arguments of tensor_probability (state and measurements) for convenience.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.tensor_correlation","page":"List of functions","title":"Ket.tensor_correlation","text":"tensor_correlation(p::AbstractArray, behaviour::Bool = false; collinsgisin::Bool = false, marg::Bool = true)\n\nConverts a multipartite Bell functional p into correlation notation, with marginals in the first index of each dimension. If collinsgisin is true, p is assumed to be written in Collins-Gisin notation. Otherwise, p is assumed to be written in probability notation. If marg is false, the output contains only full correlators, with no marginals. If behaviour is true do the transformation for behaviours. Doesn't assume normalization.\n\nAlso accepts the arguments of tensor_probability (state and measurements) for convenience.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.nonlocality_robustness","page":"List of functions","title":"Ket.nonlocality_robustness","text":"nonlocality_robustness(FP::Array; noise::String = \"white\", verbose::Bool = false, solver = Hypatia.Optimizer{_solver_type(T)})\n\nComputes the nonlocality robustness of the behaviour FP. Argument noise indicates the kind of noise to be used: \"white\" (default), \"local\", or \"general\".\n\nReference: Baek, Ryu, Lee, arxiv:2311.07077\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.trace_norm","page":"List of functions","title":"Ket.trace_norm","text":"trace_norm(X::AbstractMatrix)\n\nComputes trace norm of matrix X.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.kyfan_norm","page":"List of functions","title":"Ket.kyfan_norm","text":"kyfan_norm(X::AbstractMatrix, k::Integer, p::Real = 2)\n\nComputes Ky-Fan (k,p) norm of matrix X.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.schatten_norm","page":"List of functions","title":"Ket.schatten_norm","text":"schatten_norm(X::AbstractMatrix, p::Real)\n\nComputes Schatten p-norm of matrix X.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.diamond_norm","page":"List of functions","title":"Ket.diamond_norm","text":"diamond_norm(\n    J::AbstractMatrix,\n    dims::AbstractVector;\n    verbose::Bool = false,\n    solver = Hypatia.Optimizer{_solver_type(T)})\n\nComputes the diamond norm of the supermap J given in the Choi-Jamiołkowski representation, with subsystem dimensions dims.\n\nReference: Diamond norm\n\n\n\n\n\ndiamond_norm(K::Vector{<:AbstractMatrix})\n\nComputes the diamond norm of the CP map given by the Kraus operators K.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.parameterized_unitary","page":"List of functions","title":"Ket.parameterized_unitary","text":"parameterized_unitary(λ::AbstractMatrix{T})\n\nProduces the unitary matrix parameterized by λ.\n\nReference: Spengler, Huber, Hiesmayr, arXiv:1004.5252\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.random_state","page":"List of functions","title":"Ket.random_state","text":"random_state([T=ComplexF64,] d::Integer, k::Integer = d)\n\nProduces a uniformly distributed random quantum state in dimension d with rank k.\n\nReference: Życzkowski and Sommers, arXiv:quant-ph/0012101\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.random_state_ket","page":"List of functions","title":"Ket.random_state_ket","text":"random_state_ket([T=ComplexF64,] d::Integer)\n\nProduces a Haar-random quantum state vector in dimension d.\n\nReference: Życzkowski and Sommers, arXiv:quant-ph/0012101\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.random_unitary","page":"List of functions","title":"Ket.random_unitary","text":"random_unitary([T=ComplexF64,] d::Integer)\n\nProduces a Haar-random unitary matrix in dimension d. If T is a real type the output is instead a Haar-random (real) orthogonal matrix.\n\nReferences: Gilbert W. Stewart, doi:10.1137/0717034             Demmel et al., lawn203\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.random_isometry","page":"List of functions","title":"Ket.random_isometry","text":"random_isometry([T=ComplexF64,] d::Integer, k::Integer)\n\nProduces a Haar-random isometry with d rows and k columns.\n\nReferences: Gilbert W. Stewart, doi:10.1137/0717034             Demmel et al., lawn203\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.random_povm","page":"List of functions","title":"Ket.random_povm","text":"random_povm([T=ComplexF64,] d::Integer, n::Integer, k::Integer)\n\nProduces a random POVM of dimension d with n outcomes and rank min(k, d).\n\nReference: Heinosaari et al., arXiv:1902.04751\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.random_probability","page":"List of functions","title":"Ket.random_probability","text":"random_probability([T=Float64,] d::Integer)\n\nProduces a random probability vector of dimension d uniformly distributed on the simplex.\n\nReference: Dirichlet distribution\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_bell_ket","page":"List of functions","title":"Ket.state_bell_ket","text":"state_bell_ket([T=ComplexF64,] a::Integer, b::Integer, d::Integer = 2)\n\nProduces the ket of the generalized Bell state ψ_ab of local dimension d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_bell","page":"List of functions","title":"Ket.state_bell","text":"state_bell([T=ComplexF64,] a::Integer, b::Integer, d::Integer = 2, v::Real = 1)\n\nProduces the generalized Bell state ψ_ab of local dimension d with visibility v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_phiplus_ket","page":"List of functions","title":"Ket.state_phiplus_ket","text":"state_phiplus_ket([T=ComplexF64,] d::Integer = 2)\n\nProduces the ket of the maximally entangled state ϕ⁺ of local dimension d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_phiplus","page":"List of functions","title":"Ket.state_phiplus","text":"state_phiplus([T=ComplexF64,] d::Integer = 2; v::Real = 1)\n\nProduces the maximally entangled state ϕ⁺ of local dimension d with visibility v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_psiminus_ket","page":"List of functions","title":"Ket.state_psiminus_ket","text":"state_psiminus_ket([T=ComplexF64,] d::Integer = 2)\n\nProduces the ket of the maximally entangled state ψ⁻ of local dimension d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_psiminus","page":"List of functions","title":"Ket.state_psiminus","text":"state_psiminus([T=ComplexF64,] d::Integer = 2; v::Real = 1)\n\nProduces the maximally entangled state ψ⁻ of local dimension d with visibility v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_supersinglet_ket","page":"List of functions","title":"Ket.state_supersinglet_ket","text":"state_supersinglet_ket([T=ComplexF64,] N::Integer = 3; coeff = 1/√N!)\n\nProduces the ket of the N-partite N-level singlet state.\n\nReference: Adán Cabello, arXiv:quant-ph/0203119\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_supersinglet","page":"List of functions","title":"Ket.state_supersinglet","text":"state_supersinglet([T=ComplexF64,] N::Integer = 3; v::Real = 1)\n\nProduces the N-partite N-level singlet state with visibility v. This state is invariant under simultaneous rotations on all parties: (U    U) ρ (U    U) = ρ.\n\nReference: Adán Cabello, arXiv:quant-ph/0203119\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_ghz_ket","page":"List of functions","title":"Ket.state_ghz_ket","text":"state_ghz_ket([T=ComplexF64,] N::Integer = 3, d::Integer = 2; coeff = 1/√d)\n\nProduces the ket of the GHZ state with N parties and local dimension d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_ghz","page":"List of functions","title":"Ket.state_ghz","text":"state_ghz([T=ComplexF64,] N::Integer = 3, d::Integer = 2; v::Real = 1, coeff = 1/√d)\n\nProduces the GHZ state with N parties, local dimension d, and visibility v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_w_ket","page":"List of functions","title":"Ket.state_w_ket","text":"state_w_ket([T=ComplexF64,] N::Integer = 3; coeff = 1/√N)\n\nProduces the ket of the N-partite W state.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_w","page":"List of functions","title":"Ket.state_w","text":"state_w([T=ComplexF64,] N::Integer = 3; v::Real = 1, coeff = 1/√N)\n\nProduces the N-partite W state with visibility v.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_dicke_ket","page":"List of functions","title":"Ket.state_dicke_ket","text":"state_dicke_ket([T=ComplexF64,] N::Integer, k::Integer; coeff = 1/√Cᴺₖ)\n\nProduces the ket of the N-partite Dicke state with k excitations.\n\nReference: Robert H. Dicke doi:10.1103/PhysRev.93.99\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_dicke","page":"List of functions","title":"Ket.state_dicke","text":"state_dicke([T=ComplexF64,] N::Integer, k::Integer; v::Real = 1)\n\nProduces the N-partite Dicke state with k excitations.\n\nReference: Robert H. Dicke doi:10.1103/PhysRev.93.99\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_horodecki33","page":"List of functions","title":"Ket.state_horodecki33","text":"state_horodecki33([T=ComplexF64,] a::Real)\n\nProduces the 3 × 3 bipartite PPT-entangled Horodecki state with parameter a ∈ [0,1], which is PPT-entangled for a ∈ (0,1).\n\nReference: Paweł Horodecki, arXiv:quant-ph/9703004\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_horodecki24","page":"List of functions","title":"Ket.state_horodecki24","text":"state_horodecki24([T=ComplexF64,] b::Real)\n\nProduces the 2 × 4 bipartite PPT-entangled Horodecki state with parameter b ∈ [0,1], which is PPT-entangled for b ∈ (0,1).\n\nReference: Paweł Horodecki, arXiv:quant-ph/9703004\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_grid","page":"List of functions","title":"Ket.state_grid","text":"state_grid([T=ComplexF64], dA::Integer, dB::Integer, edges::Vector{Vector{ntuple{2, Int}}}; weights::Vector{T} = ones(T, length(edges)))\n\nProduces the bipartite dA × dB grid state according to the dA × dB 2D (hyper-)graph with edges and weights.\n\nReference:\n\nLockhart et al., arXiv:1705.09261\nGhimire et al., arXiv:2207.09826\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_crosshatch","page":"List of functions","title":"Ket.state_crosshatch","text":"state_crosshatch([T=ComplexF64])\n\nProduces a bound entangled bipartite 3 × 3 crosshatch state.\n\nReference: Lockhart et al., arXiv:1705.09261\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_sindici_piani_ket","page":"List of functions","title":"Ket.state_sindici_piani_ket","text":"state_sindici_piani_ket([T=ComplexF64], d::Integer, k::Integer = 1, l::Integer = d; coeff = inv(_sqrt(T, 2)))\n\nProduces the ket of Sindici-Piani state of even local dimensions d × d\n\nReference: Sindici and Piani, arXiv:1708.06595\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.state_sindici_piani","page":"List of functions","title":"Ket.state_sindici_piani","text":"state_sindici_piani([T=ComplexF64], d::Integer; coeffs = [√2/√d, ⋯, √2/√d])\n\nProduces the Sindici-Piani state of even local dimensions d × d with visibility v.\n\nReference: Sindici and Piani, arXiv:1708.06595\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.white_noise","page":"List of functions","title":"Ket.white_noise","text":"white_noise(ρ::AbstractMatrix, v::Real)\n\nReturns v * ρ + (1 - v) * id, where id is the maximally mixed state.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket.white_noise!","page":"List of functions","title":"Ket.white_noise!","text":"white_noise!(ρ::AbstractMatrix, v::Real)\n\nModifies ρ in place to tranform it into v * rho + (1 - v) * id where id is the maximally mixed state.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket._dps_constraints!","page":"List of functions","title":"Ket._dps_constraints!","text":"_dps_constraints!(model::JuMP.GenericModel, ρ::AbstractMatrix, dims::AbstractVector, n::Integer; ppt::Bool = true, is_complex::Bool = true, isometry::AbstractMatrix = I(size(ρ, 1)))\n\nConstrains state ρ of dimensions dims in JuMP model model to respect the DPS constraints of level n. Dimensions are specified in dims = [dA, dB] and the extensions will be done on the second subsystem. The extensions can be symmetric real matrices (is_complex = false) or Hermitian PSD. With ppt = true, PPT constraints are enforced for transposed subsystems 2:i, for i ∈ 2:n+1. Use isometry to specify a V to be applied in the constraint ρ = V * tr_B_2  B_n(Ξ) V.\n\nReference: Doherty, Parrilo, Spedalieri, arXiv:quant-ph/0308032\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket._inner_dps_constraints!","page":"List of functions","title":"Ket._inner_dps_constraints!","text":"_inner_dps_constraints!(model::JuMP.GenericModel, ρ::AbstractMatrix, dims::AbstractVector, n::Integer; ppt::Bool = true, is_complex::Bool = true, isometry::AbstractMatrix = I(size(ρ, 1)))\n\nConstrains state ρ of dimensions dims in JuMP model model to respect the Inner DPS constraints of level n. Dimensions are specified in dims = [dA, dB] and the extensions will be done on the second subsystem. The extensions can be symmetric real matrices (is_complex = false) or Hermitian PSD. With ppt = true, the extended part is constrained to be PPT for the [1:⌈n/2⌉+1, rest] partition.\n\nReferences: Navascués, Owari, Plenio arXiv:0906.2735 and arXiv:0906.2731\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket._partition","page":"List of functions","title":"Ket._partition","text":"partition(n::Integer, k::Integer)\n\nIf n ≥ k partitions the set 1:n into k parts as equally sized as possible. Otherwise partitions it into n parts of size 1.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ket._fiducial_WH","page":"List of functions","title":"Ket._fiducial_WH","text":"_fiducial_WH([T=ComplexF64,] d::Integer)\n\nComputes the fiducial Weyl-Heisenberg vector of dimension d.\n\nReferences:\n\nAppleby, Yadsan-Appleby, Zauner, arXiv:1209.1813\nwww.gerhardzauner.at/sicfiducials.html\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Julia","page":"Getting started","title":"Julia","text":"Ket is a Julia package, and to use it Julia must be installed. You can do that by following the instructions for your operating system in the official Julia page.\n\nJulia can be used in different ways:\n\nAs a script interpreter, by running julia script.jl in the terminal, where script.jl is a file containing Julia code.\nAs a Jupyter notebook, which resembles the Mathematica interface, and where code blocks can be mixed with text and equations.\nAs a REPL (Read-Eval-Print Loop), which is a command-line interface where you can type Julia code and get immediate feedback, similar to MATLAB and the Python interpreter.\n\nTo access the REPL, you can run julia in the terminal. You will see the julia> prompt, and you can start coding right away (you can exit the REPL with exit() or pressing Ctrl+D).\n\nIf you are new to Julia, we recommend you to check out some basic Julia tutorials such as this one before proceeding.","category":"section"},{"location":"getting_started/#Installing-Ket","page":"Getting started","title":"Installing Ket","text":"Ket can be installed by running the following command in the Julia REPL:\n\n] add Ket\n\nThe ] key opens Julia's built-in package manager, and the add command installs the package. Any officially registered package can be installed in the same way.\n\ntip: Tip\nIf you like living dangerously, you can instead install the development version by running ] add Ket#master. There is usually no benefit in doing so, as we try to make a new release whenever the codebase is in a sensible state.\n\nAfter the installation is complete, you can check that Ket is working by running the following command in the REPL:\n\nusing Ket\nket(1,2)\n\nThe using Ket command tells Julia to load the Ket package, and that make its functions available in the current session.","category":"section"},{"location":"getting_started/#Using-Ket","page":"Getting started","title":"Using Ket","text":"Ket is a package for quantum information theory, and it provides a set of tools for working with quantum states, measurements, and channels. It is designed to be user-friendly and to provide a high-level interface for common tasks in quantum information theory.\n\nThe best way to learn how to use Ket is by using the list of functions as a reference. It is designed to be self-contained and to provide examples for each function. Inside the REPL, you can also type ? followed by the name of the function to get a brief description of its usage, or use the function @doc, for example:\n\n@doc schmidt_decomposition\n\nprint(@doc schmidt_decomposition) #hide\n\nBeginners can be daunted by the first line in the function definitions, such as above, but they are only specifying the possible input arguments in terms of the types of variables. Julia's type system is very powerful, but to use Ket you only need to know a few facts.\n\nFirst, each variable in a function's input has a name, and the :: symbol can be used to specify the type of the variable. In schmidt_number, the input ψ::AbstractVector can be any vector, while dims::AbstractVector{<:Integer} is a vector of integers.\n\nSome other functions accept an optional argument to specify the return type. For example:\n\n@doc random_state\n\nprint(@doc random_state) #hide\n\nHere, the first argument [T=ComplexF64,] specifies that the return type of the function can be controlled by the user, and the default is ComplexF64. This can be used to control the precision of the computations, but it is not necessary to know about it to use the function: You can just ignore it, and a sensible default type will be used. Any argument followed by a \"=\" is optional, and the default value is specified after the \"=\" symbol (for example, d::Integer = 2 above).\n\nFinally, some functions also have keyword arguments. They are specified after a ; in the function definition:\n\n@doc entanglement_robustness\n\nprint(@doc entanglement_robustness) #hide\n\nThese are not positional arguments such as the ones that come before the ;. Instead, they must be passed by their names. So, for example, entanglement_robustness(ρ; noise = \"separable\") is a valid call for any matrix ρ:\n\nλ, W = entanglement_robustness(state_ghz(2, 2); noise = \"separable\")\nλ #hide\n\nW #hide\n\ntip: Tip\nJulia's REPL has a tab-completion feature that can be used to explore the functions available in Ket. You can type Ket. and press Tab to see a list of functions, or start the name of a function (e.g., state_) and press Tab to see a list of available states.","category":"section"},{"location":"getting_started/#Further-resources","page":"Getting started","title":"Further resources","text":"Knowing how to use the documentation should enable you to start adding the functions provided by Ket to your code right away. If you are still unsure of what to do, or not yet convinced that Ket is useful for you, you may check some of the examples on the sidebar.\n\nOther than learning the basics of Julia, we also recommend you to check the JuMP tutorial to learn how to use Julia for optimization problems. This is one of the most popular uses of Julia, and it is very easy to use it with Ket to solve quantum information problems. Ket integrates well with JuMP, offering for example functions that add common constraints to user-defined optimization problems, such as Ket._dps_constraints! and Ket._inner_dps_constraints!.\n\nFinally, if you have any questions, suggestions, bug reports, or wish to contribute with code or examples, you can reach out to us or open an issue in the Ket repository.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/tilted_chsh/#Tilted-CHSH-inequality","page":"Tilted CHSH inequality","title":"Tilted CHSH inequality","text":"Given a Bell expression we often want to compute its local bound and the maximum quantum violation. In Ket this can easily be done using the functions local_bound, seesaw and tsirelson_bound.\n\nWe will use the tilted CHSH inequality as an example (see Acín et al.’s “Randomness versus nonlocality and entanglement”):\n\nalpha langle A_0 rangle + langle A_0 B_0 rangle + langle A_0 B_1 rangle + langle A_1 B_0 rangle - langle A_1 B_1 rangle oversetCleqslant 2+alpha oversetQleqslant sqrt8+2alpha^2\n\nIn this expression, the C bound is the local bound (that is, achievable with classical systems), and the Q bound is the analytical solution for the maximum violation using quantum systems. (Of course, in general we do not know the quantum bounds for an arbitrary inequality, this example is so we can compare the results we will obtain via optimization.)\n\nLet us first define the Bell expression in the full probability representation:\n\ntip: Tip\nYou can convert between behavior representations using the functions tensor_probability, tensor_collinsgisin and tensor_correlation. They also accept a state and a set of measurements as inputs, returning the corresponding behavior.\n\nfunction tilted_chsh(α)\n    # in correlator notation, the tilted CHSH is:\n    return [0  α  0;\n            0  1  1;\n            0  1 -1]\nend\nprintln() #hide\n\nComputing the local bound amounts to finding the maximum of the expression over all deterministic strategies. This can be done using the local_bound function, which can be called on any expression written in correlation or full probability format.\n\nusing Ket\n\n# we take 10 different values of α\nα = LinRange(0, 1, 10)\n# the `.` operator applies the function to each element of the vector\nlocal_bounds = local_bound.(tilted_chsh.(α))\n\nFor the quantum value, we can:\n\nObtain lower bounds (with a quantum realization in a given dimension) using the seesaw function,  whose inputs are an inequality in the Collins-Gisin representation, a vector specifying the scenario, and the dimension.  Since the seesaw algorithm can get trapped in local maxima, it is recommended to run it multiple times and select the best shot.  This is automated via the optional last argument n_trials.\nObtain upper bounds using the tsirelson_bound function, which is based on the NPA hierarchy.  It takes an inequality in the Collins-Gisin or full probability representation, a vector specifying the scenario  (the number of outcomes and inputs per party), and the level of the NPA hierarchy.\n\ntilted_chsh_cg(α) = tensor_collinsgisin(tilted_chsh(α); correlation = true)\n\n# the first output of seesaw is the bound\nquantum_bounds_seesaw = [seesaw(tilted_chsh_cg(αi), (2, 2, 2, 2), 2, 100)[1] for αi in α]\n\nquantum_bounds_npa1 = [tsirelson_bound(tilted_chsh_cg(αi), (2, 2, 2, 2), 1)[1] for αi in α]\nquantum_bounds_npa2 = [tsirelson_bound(tilted_chsh_cg(αi), (2, 2, 2, 2), 2)[1] for αi in α]\nprintln() #hide\n\nTo visualize the bounds, we can plot the results and compare them to the analytical solutions:\n\nusing Plots\n\nxs = LinRange(0, 1, 100)\n\nplt = plot(xs, (x -> 2 + x).(xs), label = \"Local bound (analytical)\", linewidth = 2.5)\nscatter!(α, local_bounds, label = \"Local bound (numerical)\", markersize = 5, markershape = :circle)\n\nplot!(xs, (x -> sqrt(8 + 2x^2)).(xs), label = \"Quantum bound (analytical)\", linewidth = 2.5)\nscatter!(α, quantum_bounds_seesaw, label = \"Quantum bound (seesaw)\", markersize = 4, markershape = :square)\nscatter!(α, quantum_bounds_npa1, label = \"Quantum bound (NPA 1)\", markersize = 5, markershape = :diamond)\nscatter!(α, quantum_bounds_npa2, label = \"Quantum bound (NPA 2)\", markersize = 4, markershape = :utriangle)\nplot!(xlabel = \"α\", title = \"α⟨A₀⟩ + CHSH\")\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"contribution_guide/#Contribution-guide","page":"Contributing","title":"Contribution guide","text":"We welcome and encourage contributions to Ket. This guide explains some ways to contribute.\n\ntip: Tip\nQuestions, suggestions, bugs and so forth can be added as an issue on the repository. You can also find us on Slack.","category":"section"},{"location":"contribution_guide/#Contributing-code","page":"Contributing","title":"Contributing code","text":"The basic guidelines for contributing code are:\n\nThe problems to be solved should be of wide and recurrent use, but not trivial.\nFunctions must have docstrings explaining the inputs and usage.\nEvery function should come with automated tests (these tests are automatically run on every commit to verify nothing is broken).\nTry to write fast code, for example by enforcing type stability and reusing existing, optimized code.\nUse generic typing to enable arbitrary precision computations.\nMinimize dependencies on external packages.\n\nThere are only three steps to add a new function to Ket:\n\nWrite the function and the docstring in the appropriate file of the source code, maintaining the same code formatting style.\nThink of some tests to guarantee that your function is working as intended and add them to the test files.\nInclude your function's name in the list of functions so that it appears in the documentation.\n\nYou should then do a pull request to the repository, and all the automated tests will run. It is a good idea to run the tests locally before committing to the repository.\n\ntip: Tip\nThis procedure can sound complicated if you do not have experience with Git and Julia development. Checking the JuMP guide or Modern Julia Workflows may help, otherwise reach out for someone to walk you through the process.\n\nIf you have an idea for a contribution but are unsure if it is useful, consider proposing it beforehand. Otherwise, if you want to contribute but have no ideas, there is a TODO list. You can also reach out to us if you need help optimizing your code or using generic types.","category":"section"},{"location":"contribution_guide/#Documentation","page":"Contributing","title":"Documentation","text":"Another helpful way of contributing to Ket is to improve the documentation with new examples or improved docstrings.","category":"section"},{"location":"contribution_guide/#Contributing-examples","page":"Contributing","title":"Contributing examples","text":"We encourage submissions of examples that build on Ket. Doing this is very simple: You just have to write a .jl file that may contain Markdown (text, equations etc.) and Julia code, then add it to the Ket.jl/docs/src/examples directory.\n\nWhen this is committed to the repository, the example files will be automatically processed and displayed in the documentation.  You can follow the syntax from the existing examples, or check out the documentation for Literate.jl.","category":"section"},{"location":"contribution_guide/#Docstrings","page":"Contributing","title":"Docstrings","text":"The list of functions is the most important part of the documentation, and its purpose is to explain how each function works, including the input arguments and the expected results. This list is generated automatically from the \"docstrings\" that precede each function in the source code. \n\nIf you find something that can be clarified or extended, you can suggest or submit modifications to the docstrings.","category":"section"},{"location":"contribution_guide/#Bug-reports","page":"Contributing","title":"Bug reports","text":"Whenever you notice crashing code, incorrect implementations, or performance issues, please open an issue on the repository. Include as much information about the problem as you can, and ideally provide a minimal working example of code where the problem appears. In case you understand the issue, you can also suggest a fix or consider submitting a patch.","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Banner)\n\n(Image: Dev) (Image: DOI)\n\nKet is a toolbox for quantum information, nonlocality, and entanglement written in the Julia programming language. All its functions are designed to work with generic types, allowing one to use Int64 or Float64 for efficiency, or arbitrary precision types when needed. Wherever possible they can be also used for optimization with JuMP. And everything is optimized to the last microsecond.\n\nHighlights:\n\nWork with multipartite Bell inequalities, computing their local bounds and Tsirelson bounds with local_bound and tsirelson_bound, and transforming between Collins-Gisin, probability, and correlation representations with tensor_collinsgisin, tensor_probability, and tensor_correlation.\nWork with bipartite entanglement by computing the relative entropy of entanglement, entanglement robustness, or Schmidt number via entanglement_entropy, entanglement_robustness, and schmidt_number. Under the hood these functions use the DPS hierarchy, which is also available in isolation via _dps_constraints!.\nGenerate MUBs and SIC-POVMs through mub and sic_povm.\nGenerate uniformly-distributed random states, unitaries, and POVMs with random_state, random_unitary, and random_povm.\nGenerate well-known families of quantum states, such as the Bell states, the GHZ state, the W state, the Dicke states, and the super-singlet via state_bell, state_ghz, state_w, state_dicke, and state_supersinglet.\nWork with multilinear algebra via utility functions such as partial_trace, partial_transpose, and permute_systems.\nCompute Shannon, von Neumann, and Rényi entropies with functions such as entropy, relative_entropy, and conditional_entropy.\nGenerate kets with ket.\n\nFor the full list of functions see the documentation.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Ket is a registered Julia package, so it can be installed by typing the following command in the Julia REPL:\n\n]add Ket","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"We welcome suggestions, bug reports, documentation and code contributions.  See the contributions guide for more information.","category":"section"},{"location":"#Related-libraries","page":"Home","title":"Related libraries","text":"Julia:\n\nQuantumClifford.jl\nQuantumOptics.jl\nQuantumToolbox.jl\nYao.jl\n\nPython:\n\ntoqito\n\nMATLAB:\n\nQETLAB","category":"section"}]
}
