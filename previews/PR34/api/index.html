<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>List of functions · Ket.jl</title><meta name="title" content="List of functions · Ket.jl"/><meta property="og:title" content="List of functions · Ket.jl"/><meta property="twitter:title" content="List of functions · Ket.jl"/><meta name="description" content="Documentation for Ket.jl."/><meta property="og:description" content="Documentation for Ket.jl."/><meta property="twitter:description" content="Documentation for Ket.jl."/><meta property="og:url" content="https://dev-ket.github.io/Ket.jl/api/"/><meta property="twitter:url" content="https://dev-ket.github.io/Ket.jl/api/"/><link rel="canonical" href="https://dev-ket.github.io/Ket.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Ket.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Ket.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li class="is-active"><a class="tocitem" href>List of functions</a><ul class="internal"><li><a class="tocitem" href="#Basic"><span>Basic</span></a></li><li><a class="tocitem" href="#Multilinear-algebra"><span>Multilinear algebra</span></a></li><li><a class="tocitem" href="#Channels"><span>Channels</span></a></li><li><a class="tocitem" href="#Entanglement"><span>Entanglement</span></a></li><li><a class="tocitem" href="#Entropy"><span>Entropy</span></a></li><li><a class="tocitem" href="#Incompatibility"><span>Incompatibility</span></a></li><li><a class="tocitem" href="#Measurements"><span>Measurements</span></a></li><li><a class="tocitem" href="#Nonlocality"><span>Nonlocality</span></a></li><li><a class="tocitem" href="#Norms"><span>Norms</span></a></li><li><a class="tocitem" href="#Parameterizations"><span>Parameterizations</span></a></li><li><a class="tocitem" href="#Random"><span>Random</span></a></li><li><a class="tocitem" href="#States"><span>States</span></a></li><li><a class="tocitem" href="#Internal-functions"><span>Internal functions</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/tilted_chsh/">Tilted CHSH inequality</a></li></ul></li><li><a class="tocitem" href="../contribution_guide/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>List of functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>List of functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/dev-ket/Ket.jl/blob/master/docs/src/api.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="List-of-functions"><a class="docs-heading-anchor" href="#List-of-functions">List of functions</a><a id="List-of-functions-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-functions" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="Ket"><a class="docstring-binding" href="#Ket"><code>Ket</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>Toolbox for quantum information, nonlocality, and entanglement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/Ket.jl#L1-L3">source</a></section></details></article><h2 id="Basic"><a class="docs-heading-anchor" href="#Basic">Basic</a><a id="Basic-1"></a><a class="docs-heading-anchor-permalink" href="#Basic" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Ket.ket"><a class="docstring-binding" href="#Ket.ket"><code>Ket.ket</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ket([T=Bool,] i::Integer, d::Integer)</code></pre><p>Produces a ket of dimension <code>d</code> with nonzero element <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/basic.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.ketbra"><a class="docstring-binding" href="#Ket.ketbra"><code>Ket.ketbra</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ketbra(v::AbstractVector)</code></pre><p>Produces a ketbra of vector <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/basic.jl#L14-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.proj"><a class="docstring-binding" href="#Ket.proj"><code>Ket.proj</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">proj([T=Bool,] i::Integer, d::Integer)</code></pre><p>Produces a projector onto the basis state <code>i</code> in dimension <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/basic.jl#L24-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.shift"><a class="docstring-binding" href="#Ket.shift"><code>Ket.shift</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">shift([T=ComplexF64,] d::Integer, p::Integer = 1)</code></pre><p>Constructs the shift operator X of dimension <code>d</code> to the power <code>p</code>.</p><p>Reference: <a href="https://en.wikipedia.org/wiki/Generalized_Clifford_algebra">Generalized Clifford algebra</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/basic.jl#L37-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.clock"><a class="docstring-binding" href="#Ket.clock"><code>Ket.clock</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">clock([T=ComplexF64,] d::Integer, q::Integer = 1)</code></pre><p>Constructs the clock operator Z of dimension <code>d</code> to the power <code>q</code>.</p><p>Reference: <a href="https://en.wikipedia.org/wiki/Generalized_Clifford_algebra">Generalized Clifford algebra</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/basic.jl#L54-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.shiftclock"><a class="docstring-binding" href="#Ket.shiftclock"><code>Ket.shiftclock</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">shiftclock(v::AbstractVector, p::Integer, q::Integer)</code></pre><p>Produces X^<code>p</code> * Z^<code>q</code> * <code>v</code>, where X and Z are the shift and clock operators of dimension length(<code>v</code>).</p><p>Reference: <a href="https://en.wikipedia.org/wiki/Generalized_Clifford_algebra">Generalized Clifford algebra</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/basic.jl#L72-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.pauli"><a class="docstring-binding" href="#Ket.pauli"><code>Ket.pauli</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pauli([T=ComplexF64,], ind::Vector{&lt;:Integer})</code></pre><p>Constructs the Pauli matrices: 0 or &quot;I&quot; for the identity, 1 or &quot;X&quot; for the Pauli X operation, 2 or &quot;Y&quot; for the Pauli Y operator, and 3 or &quot;Z&quot; for the Pauli Z operator. Vectors of integers between 0 and 3 or strings of I, X, Y, Z automatically generate Kronecker products of the corresponding operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/basic.jl#L106-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.gellmann"><a class="docstring-binding" href="#Ket.gellmann"><code>Ket.gellmann</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gellmann([T=ComplexF64,], d::Integer = 3; coeff = √(d/2))</code></pre><p>Constructs the set <code>G</code> of generalized <code>d</code>-dimensional Gell-Mann matrices normalized such that <code>G₁ = I</code> and <code>Tr(GᵢGⱼ) = d δᵢⱼ</code>. Set <code>coeff = 1</code> to obtain the generalized Gell-Mann matrices normalized such that <code>G₁ = √(2/d) I</code> and <code>Tr(GᵢGⱼ) = 2 δᵢⱼ</code>.</p><p>Reference: <a href="https://en.wikipedia.org/wiki/Generalizations_of_Pauli_matrices">Generalizations of Pauli matrices</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/basic.jl#L152-L161">source</a></section><section><div><pre><code class="language-julia hljs">gellmann([T=ComplexF64,], i::Integer, j::Integer, d::Integer = 3)</code></pre><p>Constructs the set <code>i</code>,<code>j</code>th Gell-Mann matrix of dimension <code>d</code>.</p><p>Reference: <a href="https://en.wikipedia.org/wiki/Generalizations_of_Pauli_matrices">Generalizations of Pauli matrices</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/basic.jl#L168-L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.gellmann!"><a class="docstring-binding" href="#Ket.gellmann!"><code>Ket.gellmann!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gellmann!(res::AbstractMatrix{T}, i::Integer, j::Integer, d::Integer = 3)</code></pre><p>In-place version of <code>gellmann</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/basic.jl#L186-L190">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.bloch_vector"><a class="docstring-binding" href="#Ket.bloch_vector"><code>Ket.bloch_vector</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">bloch_vector(ρ::AbstractMatrix, basis = gellmann(checksquare(ρ)))</code></pre><p>Returns the coordinates of a <code>d × d</code> hermitian matrix in a specified basis, by default the generalized Gell-Mann basis (see <code>gellmann</code>). For density matrices, the resulting vector <code>v</code> is such that <code>v₁ = 1</code> and <code>norm(v[2:end]) ≤ √(d-1)</code> (with equality for pure states).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/basic.jl#L220-L227">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.bloch_operator"><a class="docstring-binding" href="#Ket.bloch_operator"><code>Ket.bloch_operator</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">bloch_operator(v::AbstractVector, basis = gellmann(isqrt(length(v) + 1)))</code></pre><p>Produces the operator corresponding to the Bloch vector <code>v</code>.</p><p>For qubits with the default <code>basis</code> (Pauli operators):</p><ul><li>if <code>v</code> has length <code>3</code>, the output is <code>½(I + v₁σ₁ + v₂σ₂ + v₃σ₃)</code>,</li><li>if <code>v</code> has length <code>4</code>, the output is <code>½(v₁I + v₂σ₁ + v₃σ₂ + v₄σ₃)</code>.</li></ul><p>In general:</p><ul><li>if <code>v</code> has length <code>d²-1</code>, the output is <code>(I+v⋅basis[2:end])/d</code>,</li><li>if <code>v</code> has lengh <code>d²</code>, the output is <code>v⋅basis/d</code>.</li></ul><p>No checks are performed on the result.</p><p>Reference: Eltschka et al. <a href="https://arxiv.org/abs/2012.00587">arXiv:2012.00587</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/basic.jl#L238-L254">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.cleanup!"><a class="docstring-binding" href="#Ket.cleanup!"><code>Ket.cleanup!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cleanup!(M::AbstractArray{T}; tol = _eps(T))</code></pre><p>Zeroes out real or imaginary parts of <code>M</code> that are smaller than <code>tol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/basic.jl#L272-L276">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.symmetric_projector"><a class="docstring-binding" href="#Ket.symmetric_projector"><code>Ket.symmetric_projector</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">symmetric_projector(dim::Integer, n::Integer)</code></pre><p>Computes the projector onto the symmetric subspace of <code>n</code> copies of a <code>dim</code>-dimensional space.</p><p>Reference: <a href="https://cs.uwaterloo.ca/~watrous/TQI/">Watrous&#39; book</a>, Sec. 7.1.1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/basic.jl#L329-L335">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.symmetric_isometry"><a class="docstring-binding" href="#Ket.symmetric_isometry"><code>Ket.symmetric_isometry</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">symmetric_isometry(dim::Integer, n::Integer)</code></pre><p>Computes an isometry that encodes the symmetric subspace of <code>n</code> copies of a <code>dim</code>-dimensional space. Specifically, it maps a vector space of dimension <code>binomial(n + dim -1, dim -1)</code> onto the symmetric subspace of the symmetric subspace of the vector space of dimension <code>dim^n</code>.</p><p>Reference: <a href="https://cs.uwaterloo.ca/~watrous/TQI/">Watrous&#39; book</a>, Sec. 7.1.1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/basic.jl#L348-L354">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.orthonormal_range"><a class="docstring-binding" href="#Ket.orthonormal_range"><code>Ket.orthonormal_range</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">orthonormal_range(A::AbstractMatrix{T}; tol::T=nothing) where {T&lt;:Number}</code></pre><p>Orthonormal basis for the range of <code>A</code>. When <code>A</code> is sparse and <code>T</code> ∈ [<code>Float64</code>, <code>ComplexF64</code>, <code>Float32</code>, <code>ComplexF32</code>], uses a QR factorization and returns a sparse result, otherwise uses an SVD and returns a dense matrix. Tolerance <code>tol</code> is used to compute the rank and is automatically set if not provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/basic.jl#L313-L319">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.n_body_basis"><a class="docstring-binding" href="#Ket.n_body_basis"><code>Ket.n_body_basis</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">n_body_basis(
n::Integer,
n_parties::Integer;
sb::AbstractVector{&lt;:AbstractMatrix} = [pauli(1), pauli(2), pauli(3)],
eye::AbstractMatrix = I(size(sb[1], 1))</code></pre><p>Return the basis of <code>n</code> nontrivial operators acting on <code>n_parties</code>, by default using sparse Pauli matrices.</p><p>For example, <code>n_body_basis(2, 3)</code> generates all products of two Paulis and one identity, so <span>${X ⊗ X ⊗ 1, X ⊗ 1 ⊗ X, ..., X ⊗ Y ⊗ 1, ..., 1 ⊗ Z ⊗ Z}$</span>.</p><p>Instead of Paulis, a basis can be provided by the parameter <code>sb</code>, and the identity can be changed with <code>eye</code>.</p><p>This function returns a generator, which can then be used e.g. in for loops without fully allocating the entire basis at once. If you need a vector, call <code>collect</code> on it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/basic.jl#L364-L380">source</a></section></details></article><h2 id="Multilinear-algebra"><a class="docs-heading-anchor" href="#Multilinear-algebra">Multilinear algebra</a><a id="Multilinear-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Multilinear-algebra" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Ket.applymap_subsystem"><a class="docstring-binding" href="#Ket.applymap_subsystem"><code>Ket.applymap_subsystem</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">applymap_subsystem(op::AbstractMatrix, ψ::AbstractVector, subsystems::Union{Integer, AbstractVector{&lt;:Integer}}, dims::AbstractVector = _equal_sizes(ρ))</code></pre><p>Applies the operator <code>op</code> to the subsytem of <code>ρ</code> identified by <code>subsystems</code>, resulting in (op ⊗ I) * ψ. If the argument <code>dims</code> is omitted two equally-sized subsystems are assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/multilinear.jl#L350-L355">source</a></section><section><div><pre><code class="language-julia hljs">applymap_subsystem(K::AbstractVector{&lt;:AbstractMatrix}, ρ::AbstractMatrix, subsystems::Union{Integer, AbstractVector{&lt;:Integer}}, dims::AbstractVector = _equal_sizes(ρ))</code></pre><p>Applies the Kraus operators in <code>K</code> to the subsytems of <code>ρ</code> identified by <code>subsystems</code>, resulting in ∑ᵢ(K[i] ⊗ I) * ρ * (K[i]&#39; ⊗ I). If the argument <code>dims</code> is omitted two equally-sized subsystems are assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/multilinear.jl#L408-L413">source</a></section><section><div><pre><code class="language-julia hljs">applymap_subsystem(K::AbstractVector{&lt;:AbstractSparseArray}, ρ::AbstractSparseArray, subsystems::Union{Integer, AbstractVector{&lt;:Integer}}, dims::AbstractVector = _equal_sizes(ρ))</code></pre><p>Applies the sparse Kraus operators in <code>K</code> to the subsytems of a sparse matrix <code>ρ</code> identified by <code>subsystems</code>, resulting in ∑ᵢ(K[i] ⊗ I) * ρ * (K[i]&#39; ⊗ I). If the argument <code>dims</code> is omitted two equally-sized subsystems are assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/multilinear.jl#L485-L490">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.partial_trace"><a class="docstring-binding" href="#Ket.partial_trace"><code>Ket.partial_trace</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">partial_trace(X::AbstractMatrix, remove::Union{Integer, AbstractVector{&lt;:Integer}}, dims::AbstractVector = _equal_sizes(X))</code></pre><p>Takes the partial trace of matrix <code>X</code> with subsystem dimensions <code>dims</code> over the subsystems in <code>remove</code>. If the argument <code>dims</code> is omitted two equally-sized subsystems are assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/multilinear.jl#L89-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.partial_transpose"><a class="docstring-binding" href="#Ket.partial_transpose"><code>Ket.partial_transpose</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">partial_transpose(X::AbstractMatrix, transp::Union{Integer, AbstractVector{&lt;:Integer}}, dims::AbstractVector = _equal_sizes(X))</code></pre><p>Takes the partial transpose of matrix <code>X</code> with subsystem dimensions <code>dims</code> over the subsystems in <code>transp</code>. If the argument <code>dims</code> is omitted two equally-sized subsystems are assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/multilinear.jl#L143-L148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.permute_systems"><a class="docstring-binding" href="#Ket.permute_systems"><code>Ket.permute_systems</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">permute_systems(X::AbstractVector, perm::AbstractVector, dims::AbstractVector = _equal_sizes(X))</code></pre><p>Permutes the order of the subsystems of vector <code>X</code> with subsystem dimensions <code>dims</code> according to the permutation <code>perm</code>. If the argument <code>dims</code> is omitted two equally-sized subsystems are assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/multilinear.jl#L216-L221">source</a></section><section><div><pre><code class="language-julia hljs">permute_systems(X::AbstractMatrix, perm::AbstractVector, dims::AbstractVector = _equal_sizes(X))</code></pre><p>Permutes the order of the subsystems of the square matrix <code>X</code>, which is composed by square subsystems of dimensions <code>dims</code>, according to the permutation <code>perm</code>. If the argument <code>dims</code> is omitted two equally-sized subsystems are assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/multilinear.jl#L233-L238">source</a></section><section><div><pre><code class="language-julia hljs">permute_systems(X::AbstractMatrix, perm::Vector, dims::Matrix)</code></pre><p>Permutes the order of the subsystems of the matrix <code>X</code>, which is composed by subsystems of dimensions <code>dims</code>, according to the permutation <code>perm</code>. <code>dims</code> should be a n × 2 matrix where <code>dims[i, 1]</code> is the number of rows of subsystem i, and <code>dims[i, 2]</code> is its number of columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/multilinear.jl#L259-L264">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.permutation_matrix"><a class="docstring-binding" href="#Ket.permutation_matrix"><code>Ket.permutation_matrix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">permutation_matrix(dims::Union{Integer,AbstractVector}, perm::AbstractVector)</code></pre><p>Unitary that permutes subsystems of dimension <code>dims</code> according to the permutation <code>perm</code>. If <code>dims</code> is an Integer, assumes there are <code>length(perm)</code> subsystems of equal dimensions <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/multilinear.jl#L273-L278">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.trace_replace"><a class="docstring-binding" href="#Ket.trace_replace"><code>Ket.trace_replace</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">trace_replace(X::AbstractMatrix, replace::Union{Integer, AbstractVector{&lt;:Integer}}, dims::AbstractVector = _equal_sizes(X))</code></pre><p>Takes the partial trace of matrix <code>X</code> with subsystem dimensions <code>dims</code> over the subsystems in <code>replace</code> and replace them with normalized identity. If the argument <code>dims</code> is omitted two equally-sized subsystems are assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/multilinear.jl#L292-L298">source</a></section></details></article><h2 id="Channels"><a class="docs-heading-anchor" href="#Channels">Channels</a><a id="Channels-1"></a><a class="docs-heading-anchor-permalink" href="#Channels" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Ket.applymap"><a class="docstring-binding" href="#Ket.applymap"><code>Ket.applymap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">applymap(K::Vector{&lt;:AbstractMatrix}, M::AbstractMatrix)</code></pre><p>Applies the CP map given by the Kraus operators <code>K</code> to the matrix <code>M</code>. Preserves sparsity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/channels.jl#L13-L17">source</a></section><section><div><pre><code class="language-julia hljs">applymap(Φ::AbstractMatrix, M::AbstractMatrix)</code></pre><p>Applies the CP map given by the Choi-Jamiołkowski operator <code>Φ</code> to the matrix <code>M</code>. Preserves sparsity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/channels.jl#L50-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.applymap!"><a class="docstring-binding" href="#Ket.applymap!"><code>Ket.applymap!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">applymap!(result::AbstractMatrix, K::Vector{&lt;:AbstractMatrix}, M::AbstractMatrix, temp::AbstractMatrix)</code></pre><p>Applies the CP map given by the Kraus operators <code>K</code> to the matrix <code>M</code> without allocating or wrapping. <code>result</code> and <code>temp</code> must be matrices of size <code>dout × dout</code> and <code>dout × din</code>, where <code>dout, din == size(K[1])</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/channels.jl#L33-L38">source</a></section><section><div><pre><code class="language-julia hljs"> applymap!(result::AbstractMatrix, Φ::AbstractMatrix, M::AbstractMatrix)</code></pre><p>Applies the CP map given by the Choi-Jamiołkowski operator <code>Φ</code> to the matrix <code>M</code> without allocating or wrapping. In the symmetric or Hermitian cases only the upper triangular is computed. <code>result</code> must be a matrix of size <code>dout × dout</code>,  where <code>size(M, 1) * dout == size(Φ, 1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/channels.jl#L70-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.choi"><a class="docstring-binding" href="#Ket.choi"><code>Ket.choi</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">choi(K::Vector{&lt;:AbstractMatrix})</code></pre><p>Constructs the Choi-Jamiołkowski representation of the CP map given by the Kraus operators <code>K</code>. Preserves sparsity. The convention used is that choi(K) = ∑ᵢⱼ |i⟩⟨j|⊗K|i⟩⟨j|K&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/channels.jl#L192-L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.channel_bit_flip"><a class="docstring-binding" href="#Ket.channel_bit_flip"><code>Ket.channel_bit_flip</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">channel_bit_flip(p::Real)</code></pre><p>Return the Kraus operator representation of the bit flip channel. It applies Pauli-X with probability <code>1 − p</code> (flip from |0⟩ to |1⟩ and vice versa).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/channels.jl#L94-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.channel_phase_damping"><a class="docstring-binding" href="#Ket.channel_phase_damping"><code>Ket.channel_phase_damping</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">channel_phase_damping(λ::Real)</code></pre><p>Return the Kraus operator representation of the phase damping channel. It describes the photon scattering or electron perturbation. &#39;λ&#39; is the probability being scattered or perturbed (without loss of energy).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/channels.jl#L180-L184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.channel_phase_flip"><a class="docstring-binding" href="#Ket.channel_phase_flip"><code>Ket.channel_phase_flip</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">channel_phase_flip(p::Real)</code></pre><p>Return the Kraus operator representation of the phase flip channel. It applies Pauli-Z with probability <code>1 − p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/channels.jl#L106-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.channel_amplitude_damping"><a class="docstring-binding" href="#Ket.channel_amplitude_damping"><code>Ket.channel_amplitude_damping</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">channel_amplitude_damping(γ::Real)</code></pre><p>Return the Kraus operator representation of the amplitude damping channel. It describes the effect of dissipation to an environment at zero temperature. <code>γ</code> is the probability of the system to decay to the ground state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/channels.jl#L149-L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.channel_amplitude_damping_generalized"><a class="docstring-binding" href="#Ket.channel_amplitude_damping_generalized"><code>Ket.channel_amplitude_damping_generalized</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">channel_amplitude_damping_generalized(rho::AbstractMatrix, p::Real, γ::Real)</code></pre><p>Return the Kraus operator representation of the generalized amplitude damping channel. It describes the effect of dissipation to an environment at finite temperature. <code>γ</code> is the probability of the system to decay to the ground state. <code>1-p</code> can be thought as the energy of the stationary state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/channels.jl#L163-L170">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.channel_bit_phase_flip"><a class="docstring-binding" href="#Ket.channel_bit_phase_flip"><code>Ket.channel_bit_phase_flip</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">channel_bit_phase_flip(p::Real)</code></pre><p>Return the Kraus operator representation of the phase flip channel. It applies Pauli-Y (=iXY) with probability <code>1 − p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/channels.jl#L118-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.channel_depolarizing"><a class="docstring-binding" href="#Ket.channel_depolarizing"><code>Ket.channel_depolarizing</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">channel_depolarizing(v::Real, d::Integer = 2)</code></pre><p>Return the Kraus operator representation of the depolarizing channel of dimension <code>d</code>. It replaces a single qudit by the completely mixed state with probability &#39;1-v&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/channels.jl#L130-L134">source</a></section></details></article><h2 id="Entanglement"><a class="docs-heading-anchor" href="#Entanglement">Entanglement</a><a id="Entanglement-1"></a><a class="docs-heading-anchor-permalink" href="#Entanglement" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Ket.schmidt_decomposition"><a class="docstring-binding" href="#Ket.schmidt_decomposition"><code>Ket.schmidt_decomposition</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">schmidt_decomposition(ψ::AbstractVector, dims::AbstractVector = _equal_sizes(ψ))</code></pre><p>Produces the Schmidt decomposition of <code>ψ</code> with subsystem dimensions <code>dims</code>. If the argument <code>dims</code> is omitted equally-sized subsystems are assumed. Returns the (sorted) Schmidt coefficients λ and isometries U, V such that kron(U&#39;, V&#39;)*<code>ψ</code> is of Schmidt form.</p><p>Reference: <a href="https://en.wikipedia.org/wiki/Schmidt_decomposition">Schmidt decomposition</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/entanglement.jl#L8-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.entanglement_entropy"><a class="docstring-binding" href="#Ket.entanglement_entropy"><code>Ket.entanglement_entropy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">entanglement_entropy(ψ::AbstractVector, dims::AbstractVector = _equal_sizes(ψ); base = 2)</code></pre><p>Computes the relative entropy of entanglement of a bipartite pure state <code>ψ</code> with subsystem dimensions <code>dims</code>. If the argument <code>dims</code> is omitted equally-sized subsystems are assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/entanglement.jl#L25-L30">source</a></section><section><div><pre><code class="language-julia hljs">entanglement_entropy(ρ::AbstractMatrix, dims::AbstractVector = _equal_sizes(ρ), n::Integer = 1; verbose = false, base = 2)</code></pre><p>Lower bounds the relative entropy of entanglement of a bipartite state <code>ρ</code> with subsystem dimensions <code>dims</code> using level <code>n</code> of the DPS hierarchy. If the argument <code>dims</code> is omitted equally-sized subsystems are assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/entanglement.jl#L39-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.entanglement_robustness"><a class="docstring-binding" href="#Ket.entanglement_robustness"><code>Ket.entanglement_robustness</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">entanglement_robustness(
    ρ::AbstractMatrix{T},
    dims::AbstractVector = _equal_sizes(ρ),
    n::Integer = 1;
    noise::String = &quot;white&quot;
    ppt::Bool = true,
    inner::Bool = false,
    verbose::Bool = false,
    dualize::Bool = false,
    solver = Hypatia.Optimizer{_solver_type(T)})</code></pre><p>Lower (or upper) bounds the entanglement robustness of state <code>ρ</code> with subsystem dimensions <code>dims</code> using level <code>n</code> of the DPS hierarchy (or inner DPS, when <code>inner = true</code>). Argument <code>noise</code> indicates the kind of noise to be used: &quot;white&quot; (default), &quot;separable&quot;, or &quot;general&quot;. Argument <code>ppt</code> indicates whether to include the partial transposition constraints. Argument <code>dualize</code> determines whether the dual problem is solved instead. WARNING: This is critical for performance, and the correct choice depends on the solver.</p><p>Returns the robustness and a witness W (note that for <code>inner = true</code>, this might not be a valid entanglement witness).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/entanglement.jl#L197-L212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.schmidt_number"><a class="docstring-binding" href="#Ket.schmidt_number"><code>Ket.schmidt_number</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">schmidt_number(
    ρ::AbstractMatrix{T},
    s::Integer = 2,
    dims::AbstractVector = _equal_sizes(ρ),
    n::Integer = 1;
    ppt::Bool = true,
    verbose::Bool = false,
    solver = Hypatia.Optimizer{_solver_type(T)})</code></pre><p>Upper bound on the white noise robustness of <code>ρ</code> such that it has a Schmidt number <code>s</code>.</p><p>If a state <span>$ρ$</span> with local dimensions <span>$d_A$</span> and <span>$d_B$</span> has Schmidt number <span>$s$</span>, then there is a PSD matrix <span>$ω$</span> in the extended space <span>$AA&#39;B&#39;B$</span>, where <span>$A&#39;$</span> and <span>$B&#39;$</span> have dimension <span>$s$</span>, such that <span>$ω / s$</span> is separable  against <span>$AA&#39;|B&#39;B$</span> and <span>$Π^† ω Π = ρ$</span>, where <span>$Π = 1_A ⊗ s ψ^+ ⊗ 1_B$</span>, and <span>$ψ^+$</span> is a non-normalized maximally entangled state. Separabiity is tested with the DPS hierarchy, with <code>n</code> controlling the how many copies of the <span>$B&#39;B$</span> subsystem are used.</p><p>References:</p><ul><li>Hulpke, Bruss, Lewenstein, Sanpera, <a href="https://arxiv.org/abs/quant-ph/0401118">arXiv:quant-ph/0401118</a></li><li>Weilenmann, Dive, Trillo, Aguilar, Navascués, <a href="https://arxiv.org/abs/1912.10056">arXiv:1912.10056</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/entanglement.jl#L135-L156">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.ppt_mixture"><a class="docstring-binding" href="#Ket.ppt_mixture"><code>Ket.ppt_mixture</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function ppt_mixture(
    ρ::AbstractMatrix{T},
    dims::AbstractVector;
    verbose::Bool = false,
    solver = Hypatia.Optimizer{_solver_type(T)})</code></pre><p>Lower bound on the white noise such that ρ is still a genuinely multipartite entangled state and a GME witness that detects ρ.</p><p>The set of GME states is approximated by the set of PPT mixtures, so the entanglement across the bipartitions is decided with the PPT criterion. If the state is a PPT mixture, returns a 0 matrix instead of a witness.</p><p>Reference: Jungnitsch, Moroder, Gühne, <a href="https://arxiv.org/abs/quant-ph/0401118">arXiv:quant-ph/0401118</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/entanglement.jl#L432-L445">source</a></section><section><div><pre><code class="language-julia hljs">function ppt_mixture(
    ρ::AbstractMatrix{T},
    dims::AbstractVector,
    obs::AbstractVector{&lt;:AbstractMatrix} = Vector{Matrix}();
    verbose::Bool = false,
    solver = Hypatia.Optimizer{_solver_type(T)})</code></pre><p>Lower bound on the white noise such that ρ is still a genuinely multipartite entangled state that can be detected with a witness using only the operators provided in <code>obs</code>, and the values of the coefficients defining such a witness.</p><p>More precisely, if a list of observables <span>$O_i$</span> is provided in the parameter <code>obs</code>, the witness will be of the form <span>$∑_i α_i O_i$</span> and detects ρ only using these observables. For example, using only two-body operators (and lower order) one can call</p><pre><code class="language-julia-repl hljs">julia&gt; two_body_basis = collect(Iterators.flatten(n_body_basis(i, 3) for i ∈ 0:2))
julia&gt; ppt_mixture(state_ghz(), [2, 2, 2], two_body_basis)</code></pre><p>Reference: Jungnitsch, Moroder, Gühne <a href="https://arxiv.org/abs/quant-ph/0401118">arXiv:quant-ph/0401118</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/entanglement.jl#L467-L489">source</a></section></details></article><h2 id="Entropy"><a class="docs-heading-anchor" href="#Entropy">Entropy</a><a id="Entropy-1"></a><a class="docs-heading-anchor-permalink" href="#Entropy" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Ket.entropy"><a class="docstring-binding" href="#Ket.entropy"><code>Ket.entropy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">entropy(ρ::AbstractMatrix{T}, α::real(T) = 1; base = 2)</code></pre><p>Computes the von Neumann entropy -tr(<code>ρ</code> log <code>ρ</code>) of a positive semidefinite operator <code>ρ</code> using a base <code>base</code> logarithm.</p><p>If given <code>α</code> != 1 computes the Rényi entropy log(tr(<code>ρ</code>^<code>α</code>)) / (1 - <code>α</code>).</p><p>References:</p><ul><li><a href="https://en.wikipedia.org/wiki/Von_Neumann_entropy">von Neumann entropy</a></li><li><a href="https://en.wikipedia.org/wiki/Rényi_entropy">Rényi entropy</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/entropy.jl#L121-L131">source</a></section><section><div><pre><code class="language-julia hljs">entropy(p::AbstractVector{T}, α::T = 1; base = 2)</code></pre><p>Computes the Shannon entropy -Σᵢ<code>p</code>ᵢlog(<code>p</code>ᵢ) of a non-negative vector <code>p</code> using a base <code>base</code> logarithm.</p><p>If <code>α != 1</code> is given computes the Rényi entropy log(Σᵢ<code>p</code>ᵢ^<code>α</code> )/(1 - <code>α</code>).</p><p>References:</p><ul><li><a href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">Entropy (information theory)</a></li><li><a href="https://en.wikipedia.org/wiki/Rényi_entropy">Rényi entropy</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/entropy.jl#L144-L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.binary_entropy"><a class="docstring-binding" href="#Ket.binary_entropy"><code>Ket.binary_entropy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">binary_entropy(p::T, α::T = T(1); base = 2)</code></pre><p>Computes the Shannon entropy -<code>p</code> log(<code>p</code>) - (1-<code>p</code>)log(1-<code>p</code>) of a probability <code>p</code> using a base <code>base</code> logarithm.</p><p>If <code>α</code> != 1 is given computes the Rényi entropy log(<code>p</code>^<code>α</code> + (1-<code>p</code>)^<code>α</code>) / (1-<code>α</code>).</p><p>References:</p><ul><li><a href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">Entropy (information theory)</a></li><li><a href="https://en.wikipedia.org/wiki/Rényi_entropy">Rényi entropy</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/entropy.jl#L166-L176">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.relative_entropy"><a class="docstring-binding" href="#Ket.relative_entropy"><code>Ket.relative_entropy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">relative_entropy(ρ::AbstractMatrix{T}, σ::AbstractMatrix{T}, α::real(T) = 1; base = 2)</code></pre><p>Computes the (quantum) relative entropy tr(<code>ρ</code> (log <code>ρ</code> - log <code>σ</code>)) between positive semidefinite matrices <code>ρ</code> and <code>σ</code> using a base <code>base</code> logarithm.</p><p>If given <code>α</code> != 1 computes the (quantum) Rényi sandwiched relative entropy log(tr((<code>σ</code>^((1-<code>α</code>)/2<code>α</code>) * <code>ρ</code> * <code>σ</code>^((1-<code>α</code>)/2<code>α</code>))^<code>α</code>)) / (<code>α</code> - 1).</p><p>Note that the support of <code>ρ</code> must be contained in the support of <code>σ</code> but for efficiency this is not checked.</p><p>References:</p><ul><li><a href="https://en.wikipedia.org/wiki/Quantum_relative_entropy">Quantum relative entropy</a></li><li><a href="https://en.wikipedia.org/wiki/Rényi_entropy">Rényi entropy</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/entropy.jl#L4-L16">source</a></section><section><div><pre><code class="language-julia hljs">relative_entropy(p::AbstractVector{T}, q::AbstractVector{T}, α::T = 1; base = 2)</code></pre><p>Computes the relative entropy Σᵢ<code>p</code>ᵢlog(<code>p</code>ᵢ/<code>q</code>ᵢ) between two non-negative vectors <code>p</code> and <code>q</code> using a base <code>base</code> logarithm.</p><p>If given <code>α</code> != 1 computes the Rényi relative entropy log(Σᵢ<code>p</code>ᵢ^<code>α</code> * <code>q</code>ᵢ^(1-<code>α</code>)) / (<code>α</code> - 1).</p><p>Note that the support of <code>p</code> must be contained in the support of <code>q</code> but for efficiency this is not checked.</p><p>References:</p><ul><li><a href="https://en.wikipedia.org/wiki/Relative_entropy">Relative entropy</a></li><li><a href="https://en.wikipedia.org/wiki/Rényi_entropy">Rényi entropy</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/entropy.jl#L53-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.binary_relative_entropy"><a class="docstring-binding" href="#Ket.binary_relative_entropy"><code>Ket.binary_relative_entropy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">binary_relative_entropy(p::T, q::T, α::T = 1; base = 2)</code></pre><p>Computes the binary relative entropy <code>p</code> log(<code>p</code>/<code>q</code>) + (1-<code>p</code>) log((1-<code>p</code>)/(1-<code>q</code>)) between two probabilities <code>p</code> and <code>q</code> using a base <code>base</code> logarithm.</p><p>If given <code>α</code> != 1 computes the Rényi binary relative entropy log(<code>p</code>^<code>α</code> * <code>q</code>^(1-<code>α</code>) + (1-<code>p</code>)^<code>α</code> * (1-<code>q</code>)^<code>α</code>) / (<code>α</code> - 1).</p><p>References:</p><ul><li><a href="https://en.wikipedia.org/wiki/Relative_entropy">Relative entropy</a></li><li><a href="https://en.wikipedia.org/wiki/Rényi_entropy">Rényi entropy</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/entropy.jl#L92-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.conditional_entropy"><a class="docstring-binding" href="#Ket.conditional_entropy"><code>Ket.conditional_entropy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">conditional_entropy(pAB::AbstractMatrix{T}, α::T = 1; base = 2)</code></pre><p>Computes the conditional Shannon entropy ∑ᵢⱼ<code>pAB</code>[i,j] * log(<code>pAB</code>[i|j]) of the joint probability distribution <code>pAB</code> using a base <code>base</code> logarithm.</p><p>If <code>α != 1</code> is given, computes the conditional Rényi entropy log(∑ⱼ<code>pAB</code>[j] * (∑ᵢ<code>pAB</code>[i|j]^α)^(1/α)) * α / (1 - α).</p><p>References:</p><ul><li><a href="https://en.wikipedia.org/wiki/Conditional_entropy">Conditional entropy</a></li><li>Müller-Lennert et al. <a href="https://arxiv.org/abs/1306.3142">arXiv:1306.3142</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/entropy.jl#L192-L202">source</a></section><section><div><pre><code class="language-julia hljs">conditional_entropy(ρ::AbstractMatrix{T}, cond::Union{Integer,AbstractVector{&lt;:Integer}}, dims::AbstractVector, α::real(T) = 1; base = 2)</code></pre><p>Computes the conditional von Neumann entropy of <code>ρ</code> with subsystem dimensions <code>dims</code> and conditioning systems <code>cond</code>, using a base <code>base</code> logarithm.</p><p>If <code>α != 1</code> is given, computes instead the following lower bound to the conditional Rényi entropy: -D<code>α</code>(<code>ρ</code>||I ⊗ <code>ρ</code>_<code>cond</code>). It is close to the true value when <code>α</code> is close to 1.</p><p>References:</p><ul><li><a href="https://en.wikipedia.org/wiki/Conditional_quantum_entropy">Conditional quantum entropy</a></li><li>Müller-Lennert et al. <a href="https://arxiv.org/abs/1306.3142">arXiv:1306.3142</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/entropy.jl#L230-L240">source</a></section></details></article><h2 id="Incompatibility"><a class="docs-heading-anchor" href="#Incompatibility">Incompatibility</a><a id="Incompatibility-1"></a><a class="docs-heading-anchor-permalink" href="#Incompatibility" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Ket.incompatibility_robustness"><a class="docstring-binding" href="#Ket.incompatibility_robustness"><code>Ket.incompatibility_robustness</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">incompatibility_robustness(
    A::Vector{Measurement{&lt;:Number}};
    noise::String = &quot;general&quot;,
    return_parent::Bool = false,
    verbose::Bool = false,
    solver = Hypatia.Optimizer{_solver_type(T)})</code></pre><p>Computes the incompatibility robustness of the measurements in the vector <code>A</code>. Depending on the noise model chosen, the second argument can be &quot;depolarizing&quot; (<code>{tr(Aₐ)I/d}ₐ</code>, where <code>d</code> is the dimension of the system), &quot;random&quot; (<code>{I/n}ₐ</code>, where <code>n</code> is the number of outcomes), &quot;probabilistic&quot; (<code>{pₐI}ₐ</code>, where <code>p</code> is a probability distribution), &quot;jointly_measurable&quot;, or &quot;general&quot; (default). Returns the parent POVM if <code>return_parent = true</code>.</p><p>References:</p><ul><li>Designolle, Farkas, Kaniewski, <a href="https://arxiv.org/abs/1906.00448">arXiv:1906.00448</a> (for the different noise models)</li><li>Gühne et al., <a href="https://arxiv.org/abs/2112.06784">arXiv:2112.06784</a> (Section III.B.2)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/incompatibility.jl#L1-L16">source</a></section></details></article><h2 id="Measurements"><a class="docs-heading-anchor" href="#Measurements">Measurements</a><a id="Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Measurements" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Ket.Measurement"><a class="docstring-binding" href="#Ket.Measurement"><code>Ket.Measurement</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Measurement{T}</code></pre><p>Alias for <code>Vector{Hermitian{T,Matrix{T}}}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/Ket.jl#L20-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.sic_povm"><a class="docstring-binding" href="#Ket.sic_povm"><code>Ket.sic_povm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sic_povm([T=ComplexF64,] d::Integer)</code></pre><p>Constructs a vector of <code>d²</code> vectors |vᵢ⟩ such that |vᵢ⟩⟨vᵢ| forms a SIC-POVM of dimension <code>d</code>. This construction is based on the Weyl-Heisenberg fiducial.</p><p>Reference: Appleby, Yadsan-Appleby, Zauner, <a href="http://arxiv.org/abs/1209.1813">arXiv:1209.1813</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/sic-povm.jl#L1-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.test_sic"><a class="docstring-binding" href="#Ket.test_sic"><code>Ket.test_sic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_sic(vecs)</code></pre><p>Checks if <code>vecs</code> is a vector of <code>d²</code> vectors |vᵢ⟩ such that |vᵢ⟩⟨vᵢ| forms a SIC-POVM of dimension <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/sic-povm.jl#L24-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.test_povm"><a class="docstring-binding" href="#Ket.test_povm"><code>Ket.test_povm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_povm(A::Vector{&lt;:AbstractMatrix{T}})</code></pre><p>Checks if the measurement defined by A is valid (hermitian, semi-definite positive, and normalized).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/measurements.jl#L170-L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.dilate_povm"><a class="docstring-binding" href="#Ket.dilate_povm"><code>Ket.dilate_povm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dilate_povm(vecs::Vector{Vector{T}})</code></pre><p>Does the Naimark dilation of a rank-1 POVM given as a vector of vectors. This is the minimal dilation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/measurements.jl#L186-L190">source</a></section><section><div><pre><code class="language-julia hljs">dilate_povm(E::Vector{&lt;:AbstractMatrix})</code></pre><p>Does the Naimark dilation of a POVM given as a vector of matrices. This always works, but is wasteful if the POVM elements are not full rank.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/measurements.jl#L204-L209">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.povm"><a class="docstring-binding" href="#Ket.povm"><code>Ket.povm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">povm(B::Vector{&lt;:AbstractMatrix{T}})</code></pre><p>Creates a set of (projective) measurements from a set of bases given as unitary matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/measurements.jl#L136-L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.povm_dichotomic"><a class="docstring-binding" href="#Ket.povm_dichotomic"><code>Ket.povm_dichotomic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">povm_dichotomic(E::AbstractMatrix)</code></pre><p>Creates the dichotomic measurement [<code>E</code>, I - <code>E</code>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/measurements.jl#L146-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.mub"><a class="docstring-binding" href="#Ket.mub"><code>Ket.mub</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mub([T=ComplexF64,] d::Integer)</code></pre><p>Construction of the standard complete set of MUBs. The output contains 1+minᵢ pᵢ^rᵢ bases, where <code>d</code> = ∏ᵢ pᵢ^rᵢ.</p><p>Reference: Durt, Englert, Bengtsson, Życzkowski, <a href="https://arxiv.org/abs/1004.3348">arXiv:1004.3348</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/measurements.jl#L70-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.test_mub"><a class="docstring-binding" href="#Ket.test_mub"><code>Ket.test_mub</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_mub(B::Vector{Matrix{&lt;:Number}})</code></pre><p>Checks if the input bases are mutually unbiased.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/measurements.jl#L111-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.discrimination_min_error"><a class="docstring-binding" href="#Ket.discrimination_min_error"><code>Ket.discrimination_min_error</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">discrimination_min_error(
    ρ::Vector{&lt;:AbstractMatrix},
    q::Vector{&lt;:Real} = fill(1/length(ρ), length(ρ));
    verbose = false,
    dualize = false,
    solver = Hypatia.Optimizer
)</code></pre><p>Computes the minimum-error probability of discriminating a vector of states <code>ρ</code> with probabilities <code>q</code>, along with the optimal POVM. <code>q</code> is assumed uniform if omitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/measurements.jl#L216-L226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.pretty_good_measurement"><a class="docstring-binding" href="#Ket.pretty_good_measurement"><code>Ket.pretty_good_measurement</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pretty_good_measurement(ρ::Vector{&lt;:AbstractMatrix}, q::Vector{&lt;:Real} = ones(length(ρ)))</code></pre><p>Computes the pretty good measurement POVM for discriminating a vector of states <code>ρ</code> with probabilities <code>q</code>. If <code>q</code> is omitted it is assumed uniform.</p><p>Reference: Watrous, <a href="https://cs.uwaterloo.ca/~watrous/TQI/TQI.3.pdf">Theory of Quantum Information Cp. 3</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/measurements.jl#L262-L268">source</a></section></details></article><h2 id="Nonlocality"><a class="docs-heading-anchor" href="#Nonlocality">Nonlocality</a><a id="Nonlocality-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlocality" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Ket.game_chsh"><a class="docstring-binding" href="#Ket.game_chsh"><code>Ket.game_chsh</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">game_chsh([T=Float64,] d::Integer = 2)</code></pre><p>CHSH-d nonlocal game in probability notation. If <code>T</code> is an integer type the game is unnormalized.</p><p>Reference: Buhrman and Massar, <a href="https://arxiv.org/abs/quant-ph/0409066">arXiv:quant-ph/0409066</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/games.jl#L1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.game_cglmp"><a class="docstring-binding" href="#Ket.game_cglmp"><code>Ket.game_cglmp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">game_cglmp([T=Float64,] d::Integer = 3)</code></pre><p>CGLMP nonlocal game in probability notation. If <code>T</code> is an integer type the game is unnormalized.</p><p>References:</p><ul><li>Collins, Gisin, Linden, Massar, Popescu, <a href="https://arxiv.org/abs/quant-ph/0106024">arXiv:quant-ph/0106024</a> (original game)</li><li>Araújo, Hirsch, Quintino, <a href="https://arxiv.org/abs/2005.13418">arXiv:2005.13418</a> (form presented here)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/games.jl#L52-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.game_braunsteincaves"><a class="docstring-binding" href="#Ket.game_braunsteincaves"><code>Ket.game_braunsteincaves</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">game_braunsteincaves([T=Float64,] s::Integer = 3)</code></pre><p>Braunstein-Caves nonlocal game in probability notation. Known in the computer science literature as odd cycle game. If <code>T</code> is an integer type the game is unnormalized.</p><p>References: Braunstein and Caves <a href="https://doi.org/10.1016/0003-4916(90)90339-P">doi:10.1016/0003-4916(90)90339-P</a> Cleve et al., <a href="https://arxiv.org/abs/quant-ph/0404076">arXiv:quant-ph/0404076</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/games.jl#L24-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.game_inn22"><a class="docstring-binding" href="#Ket.game_inn22"><code>Ket.game_inn22</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">game_inn22([T=Float64,] n::Integer = 3)</code></pre><p>inn22 Bell functional in Collins-Gisin notation. Local bound 1.</p><p>Reference: Cezary Śliwa, <a href="https://arxiv.org/abs/quant-ph/0305190">arXiv:quant-ph/0305190</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/games.jl#L77-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.game_gyni"><a class="docstring-binding" href="#Ket.game_gyni"><code>Ket.game_gyni</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gyni([T=Float64,] n::Integer)</code></pre><p>Guess your neighbour&#39;s input nonlocal game in probability notation. If <code>T</code> is an integer type the game is unnormalized.</p><p>Reference: Almeida et al., <a href="https://arxiv.org/abs/1003.3844">arXiv:1003.3844</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/games.jl#L102-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.game_mermin"><a class="docstring-binding" href="#Ket.game_mermin"><code>Ket.game_mermin</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">game_mermin([T=Float64,] n::Integer)</code></pre><p>GHZ-Mermin game in probability notation. Local bound 1/2 + 2^-ceil(<code>n</code>/2). If <code>T</code> is an integer type the game is unnormalized.</p><p>Reference: Brassard et al., <a href="https://arxiv.org/abs/quant-ph/0408052">arXiv:quant-ph/0408052</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/games.jl#L128-L135">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.local_bound"><a class="docstring-binding" href="#Ket.local_bound"><code>Ket.local_bound</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">local_bound(G::Array{T,N}; correlation = N &lt; 4, marg = true)</code></pre><p>Computes the local bound of a multipartite Bell functional <code>G</code> given as an <code>N</code>-dimensional array. If <code>correlation</code> is <code>false</code>, <code>G</code> is assumed to be written in probability notation. If <code>correlation</code> is <code>true</code>, <code>G</code> is assumed to be written in correlation notation, with or without marginals depending on <code>marg</code>.</p><p>Reference: Araújo, Hirsch, Quintino, <a href="https://arxiv.org/abs/2005.13418">arXiv:2005.13418</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/nonlocal.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.tsirelson_bound"><a class="docstring-binding" href="#Ket.tsirelson_bound"><code>Ket.tsirelson_bound</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">tsirelson_bound(CG::Array, scenario::Tuple, level; verbose::Bool = false, dualize::Bool = false, solver = Hypatia.Optimizer{_solver_type(T)})</code></pre><p>Upper bounds the Tsirelson bound of a multipartite Bell funcional <code>CG</code>, written in Collins-Gisin notation. <code>scenario</code> is a tuple detailing the number of inputs and outputs, in the order (oa, ob, ..., ia, ib, ...). <code>level</code> is an integer or a string like &quot;1 + A B&quot; determining the level of the NPA hierarchy. <code>verbose</code> determines whether solver output is printed. <code>dualize</code> determines whether the dual problem is solved instead. WARNING: This is critical for performance, and the correct choice depends on the solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/tsirelson.jl#L1-L9">source</a></section><section><div><pre><code class="language-julia hljs">tsirelson_bound(FC::Array, level; verbose::Bool = false, dualize::Bool = false, solver = Hypatia.Optimizer{_solver_type(T)})</code></pre><p>Upper bounds the Tsirelson bound of a multipartite Bell funcional <code>FC</code>, written in correlation notation. <code>level</code> is an integer or a string like &quot;1 + A B&quot; determining the level of the NPA hierarchy. <code>verbose</code> determines whether solver output is printed. <code>dualize</code> determines whether the dual problem is solved instead. WARNING: This is critical for performance, and the correct choice depends on the solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/tsirelson.jl#L44-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.seesaw"><a class="docstring-binding" href="#Ket.seesaw"><code>Ket.seesaw</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">seesaw(
    CG::Matrix,
    scenario::Tuple,
    d::Integer,
    n_trials::Integer = 1;
    verbose::Bool = false,
    solver = Hypatia.Optimizer{_solver_type(T)})</code></pre><p>Maximizes a bipartite Bell functional <code>CG</code> in Collins-Gisin notation using the seesaw heuristic. <code>scenario</code> is a vector detailing the number of inputs and outputs, in the order (<code>oa</code>, <code>ob</code>, <code>ia</code>, <code>ib</code>). <code>d</code> is an integer determining the local dimension of the strategy.</p><p>If <code>oa</code> = <code>ob</code> = 2 the heuristic reduces to a bunch of eigenvalue problems. Otherwise semidefinite programming is needed and we use the assemblage version of seesaw.</p><p>The heuristic is executed <code>n_trials</code> times, and the best result is returned.</p><p>References:</p><ul><li>Pál and Vértesi, <a href="https://arxiv.org/abs/1006.3032">arXiv:1006.3032</a></li><li>Tavakoli et al., <a href="https://arxiv.org/abs/2307.02551">arXiv:2307.02551</a> (Sec. II.B.1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/seesaw.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.tensor_probability"><a class="docstring-binding" href="#Ket.tensor_probability"><code>Ket.tensor_probability</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">tensor_probability(CG::Array, scenario::Tuple, behaviour::Bool = false)</code></pre><p>Takes a multipartite Bell functional <code>CG</code> in Collins-Gisin notation and transforms it to probability notation. <code>scenario</code> is a tuple detailing the number of inputs and outputs, in the order (oa, ob, ..., ia, ib, ...). If <code>behaviour</code> is <code>true</code> do instead the transformation for behaviours. Doesn&#39;t assume normalization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/nonlocal.jl#L359-L365">source</a></section><section><div><pre><code class="language-julia hljs">tensor_probability(FC::Matrix, behaviour::Bool = false)</code></pre><p>Takes a bipartite Bell functional <code>FC</code> in correlation notation and transforms it to probability notation. If <code>behaviour</code> is <code>true</code> do instead the transformation for behaviours. Doesn&#39;t assume normalization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/nonlocal.jl#L394-L399">source</a></section><section><div><pre><code class="language-julia hljs">tensor_probability(rho::Hermitian, all_Aax::Vector{Measurement}...)
tensor_probability(rho::Hermitian, Aax::Vector{Measurement}, N::Integer)</code></pre><p>Applies N sets of measurements onto a state <code>rho</code> to form a probability array. If all parties apply the same measurements, use the shorthand notation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/nonlocal.jl#L424-L430">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.tensor_collinsgisin"><a class="docstring-binding" href="#Ket.tensor_collinsgisin"><code>Ket.tensor_collinsgisin</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">tensor_collinsgisin(p::Array, behaviour::Bool = false; correlation::Bool = false)</code></pre><p>Converts a multipartite Bell functional <code>p</code> into Collins-Gisin notation, with marginals in the first index of each dimension. If <code>correlation</code> is <code>true</code>, <code>p</code> is assumed to be written in correlation notation. Otherwise, <code>p</code> is assumed to be written in probability notation. If <code>behaviour</code> is <code>true</code> do instead the transformation for behaviours. Doesn&#39;t assume normalization.</p><p>Also accepts the arguments of <code>tensor_probability</code> (state and measurements) for convenience.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/nonlocal.jl#L268-L277">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.tensor_correlation"><a class="docstring-binding" href="#Ket.tensor_correlation"><code>Ket.tensor_correlation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">tensor_correlation(p::AbstractArray, behaviour::Bool = false; collinsgisin::Bool = false, marg::Bool = true)</code></pre><p>Converts a multipartite Bell functional <code>p</code> into correlation notation, with marginals in the first index of each dimension. If <code>collinsgisin</code> is <code>true</code>, <code>p</code> is assumed to be written in Collins-Gisin notation. Otherwise, <code>p</code> is assumed to be written in probability notation. If <code>marg</code> is <code>false</code>, the output contains only full correlators, with no marginals. If <code>behaviour</code> is <code>true</code> do the transformation for behaviours. Doesn&#39;t assume normalization.</p><p>Also accepts the arguments of <code>tensor_probability</code> (state and measurements) for convenience.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/nonlocal.jl#L457-L467">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.nonlocality_robustness"><a class="docstring-binding" href="#Ket.nonlocality_robustness"><code>Ket.nonlocality_robustness</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nonlocality_robustness(FP::Array; noise::String = &quot;white&quot;, verbose::Bool = false, solver = Hypatia.Optimizer{_solver_type(T)})</code></pre><p>Computes the nonlocality robustness of the behaviour <code>FP</code>. Argument <code>noise</code> indicates the kind of noise to be used: &quot;white&quot; (default), &quot;local&quot;, or &quot;general&quot;.</p><p>Reference: Baek, Ryu, Lee, <a href="https://arxiv.org/abs/2311.07077">arxiv:2311.07077</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/nonlocal.jl#L574-L580">source</a></section></details></article><h2 id="Norms"><a class="docs-heading-anchor" href="#Norms">Norms</a><a id="Norms-1"></a><a class="docs-heading-anchor-permalink" href="#Norms" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Ket.trace_norm"><a class="docstring-binding" href="#Ket.trace_norm"><code>Ket.trace_norm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">trace_norm(X::AbstractMatrix)</code></pre><p>Computes trace norm of matrix <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/norms.jl#L18-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.kyfan_norm"><a class="docstring-binding" href="#Ket.kyfan_norm"><code>Ket.kyfan_norm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kyfan_norm(X::AbstractMatrix, k::Integer, p::Real = 2)</code></pre><p>Computes Ky-Fan (<code>k</code>,<code>p</code>) norm of matrix <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/norms.jl#L28-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.schatten_norm"><a class="docstring-binding" href="#Ket.schatten_norm"><code>Ket.schatten_norm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">schatten_norm(X::AbstractMatrix, p::Real)</code></pre><p>Computes Schatten <code>p</code>-norm of matrix <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/norms.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.diamond_norm"><a class="docstring-binding" href="#Ket.diamond_norm"><code>Ket.diamond_norm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">diamond_norm(
    J::AbstractMatrix,
    dims::AbstractVector;
    verbose::Bool = false,
    solver = Hypatia.Optimizer{_solver_type(T)})</code></pre><p>Computes the diamond norm of the supermap <code>J</code> given in the Choi-Jamiołkowski representation, with subsystem dimensions <code>dims</code>.</p><p>Reference: <a href="https://en.wikipedia.org/wiki/Diamond_norm">Diamond norm</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/channels.jl#L220-L230">source</a></section><section><div><pre><code class="language-julia hljs">diamond_norm(K::Vector{&lt;:AbstractMatrix})</code></pre><p>Computes the diamond norm of the CP map given by the Kraus operators <code>K</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/channels.jl#L260-L264">source</a></section></details></article><h2 id="Parameterizations"><a class="docs-heading-anchor" href="#Parameterizations">Parameterizations</a><a id="Parameterizations-1"></a><a class="docs-heading-anchor-permalink" href="#Parameterizations" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Ket.parameterized_unitary"><a class="docstring-binding" href="#Ket.parameterized_unitary"><code>Ket.parameterized_unitary</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">parameterized_unitary(λ::AbstractMatrix{T})</code></pre><p>Produces the unitary matrix parameterized by λ.</p><p>Reference: Spengler, Huber, Hiesmayr, <a href="https://arxiv.org/abs/1004.5252">arXiv:1004.5252</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/parameterizations.jl#L1-L7">source</a></section></details></article><h2 id="Random"><a class="docs-heading-anchor" href="#Random">Random</a><a id="Random-1"></a><a class="docs-heading-anchor-permalink" href="#Random" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Ket.random_state"><a class="docstring-binding" href="#Ket.random_state"><code>Ket.random_state</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">random_state([T=ComplexF64,] d::Integer, k::Integer = d)</code></pre><p>Produces a uniformly distributed random quantum state in dimension <code>d</code> with rank <code>k</code>.</p><p>Reference: Życzkowski and Sommers, <a href="https://arxiv.org/abs/quant-ph/0012101">arXiv:quant-ph/0012101</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/random.jl#L12-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.random_state_ket"><a class="docstring-binding" href="#Ket.random_state_ket"><code>Ket.random_state_ket</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">random_state_ket([T=ComplexF64,] d::Integer)</code></pre><p>Produces a Haar-random quantum state vector in dimension <code>d</code>.</p><p>Reference: Życzkowski and Sommers, <a href="https://arxiv.org/abs/quant-ph/0012101">arXiv:quant-ph/0012101</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/random.jl#L28-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.random_unitary"><a class="docstring-binding" href="#Ket.random_unitary"><code>Ket.random_unitary</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">random_unitary([T=ComplexF64,] d::Integer)</code></pre><p>Produces a Haar-random unitary matrix in dimension <code>d</code>. If <code>T</code> is a real type the output is instead a Haar-random (real) orthogonal matrix.</p><p>References: Gilbert W. Stewart, <a href="https://doi.org/10.1137/0717034">doi:10.1137/0717034</a>             Demmel et al., <a href="http://www.netlib.org/lapack/lawnspdf/lawn203.pdf">lawn203</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/random.jl#L95-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.random_isometry"><a class="docstring-binding" href="#Ket.random_isometry"><code>Ket.random_isometry</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">random_isometry([T=ComplexF64,] d::Integer, k::Integer)</code></pre><p>Produces a Haar-random isometry with <code>d</code> rows and <code>k</code> columns.</p><p>References: Gilbert W. Stewart, <a href="https://doi.org/10.1137/0717034">doi:10.1137/0717034</a>             Demmel et al., <a href="http://www.netlib.org/lapack/lawnspdf/lawn203.pdf">lawn203</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/random.jl#L122-L129">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.random_povm"><a class="docstring-binding" href="#Ket.random_povm"><code>Ket.random_povm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">random_povm([T=ComplexF64,] d::Integer, n::Integer, k::Integer)</code></pre><p>Produces a random POVM of dimension <code>d</code> with <code>n</code> outcomes and rank <code>min(k, d)</code>.</p><p>Reference: Heinosaari et al., <a href="https://arxiv.org/abs/1902.04751">arXiv:1902.04751</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/random.jl#L136-L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.random_probability"><a class="docstring-binding" href="#Ket.random_probability"><code>Ket.random_probability</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">random_probability([T=Float64,] d::Integer)</code></pre><p>Produces a random probability vector of dimension <code>d</code> uniformly distributed on the simplex.</p><p>Reference: <a href="https://en.wikipedia.org/wiki/Dirichlet_distribution#Random_variate_generation">Dirichlet distribution</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/random.jl#L162-L168">source</a></section></details></article><h2 id="States"><a class="docs-heading-anchor" href="#States">States</a><a id="States-1"></a><a class="docs-heading-anchor-permalink" href="#States" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Ket.state_bell_ket"><a class="docstring-binding" href="#Ket.state_bell_ket"><code>Ket.state_bell_ket</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_bell_ket([T=ComplexF64,] a::Integer, b::Integer, d::Integer = 2)</code></pre><p>Produces the ket of the generalized Bell state ψ_<code>ab</code> of local dimension <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L29-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_bell"><a class="docstring-binding" href="#Ket.state_bell"><code>Ket.state_bell</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_bell([T=ComplexF64,] a::Integer, b::Integer, d::Integer = 2, v::Real = 1)</code></pre><p>Produces the generalized Bell state ψ_<code>ab</code> of local dimension <code>d</code> with visibility <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L46-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_phiplus_ket"><a class="docstring-binding" href="#Ket.state_phiplus_ket"><code>Ket.state_phiplus_ket</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_phiplus_ket([T=ComplexF64,] d::Integer = 2)</code></pre><p>Produces the ket of the maximally entangled state ϕ⁺ of local dimension <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L59-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_phiplus"><a class="docstring-binding" href="#Ket.state_phiplus"><code>Ket.state_phiplus</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_phiplus([T=ComplexF64,] d::Integer = 2; v::Real = 1)</code></pre><p>Produces the maximally entangled state ϕ⁺ of local dimension <code>d</code> with visibility <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L70-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_psiminus_ket"><a class="docstring-binding" href="#Ket.state_psiminus_ket"><code>Ket.state_psiminus_ket</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_psiminus_ket([T=ComplexF64,] d::Integer = 2)</code></pre><p>Produces the ket of the maximally entangled state ψ⁻ of local dimension <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L83-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_psiminus"><a class="docstring-binding" href="#Ket.state_psiminus"><code>Ket.state_psiminus</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_psiminus([T=ComplexF64,] d::Integer = 2; v::Real = 1)</code></pre><p>Produces the maximally entangled state ψ⁻ of local dimension <code>d</code> with visibility <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L96-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_supersinglet_ket"><a class="docstring-binding" href="#Ket.state_supersinglet_ket"><code>Ket.state_supersinglet_ket</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_supersinglet_ket([T=ComplexF64,] N::Integer = 3; coeff = 1/√N!)</code></pre><p>Produces the ket of the <code>N</code>-partite <code>N</code>-level singlet state.</p><p>Reference: Adán Cabello, <a href="https://arxiv.org/abs/quant-ph/0203119">arXiv:quant-ph/0203119</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L158-L164">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_supersinglet"><a class="docstring-binding" href="#Ket.state_supersinglet"><code>Ket.state_supersinglet</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_supersinglet([T=ComplexF64,] N::Integer = 3; v::Real = 1)</code></pre><p>Produces the <code>N</code>-partite <code>N</code>-level singlet state with visibility <code>v</code>. This state is invariant under simultaneous rotations on all parties: <span>$(U ⊗ ... ⊗ U) ρ (U ⊗ ... ⊗ U)&#39; = ρ$</span>.</p><p>Reference: Adán Cabello, <a href="https://arxiv.org/abs/quant-ph/0203119">arXiv:quant-ph/0203119</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L184-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_ghz_ket"><a class="docstring-binding" href="#Ket.state_ghz_ket"><code>Ket.state_ghz_ket</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_ghz_ket([T=ComplexF64,] N::Integer = 3, d::Integer = 2; coeff = 1/√d)</code></pre><p>Produces the ket of the GHZ state with <code>N</code> parties and local dimension <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L109-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_ghz"><a class="docstring-binding" href="#Ket.state_ghz"><code>Ket.state_ghz</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_ghz([T=ComplexF64,] N::Integer = 3, d::Integer = 2; v::Real = 1, coeff = 1/√d)</code></pre><p>Produces the GHZ state with <code>N</code> parties, local dimension <code>d</code>, and visibility <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L123-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_w_ket"><a class="docstring-binding" href="#Ket.state_w_ket"><code>Ket.state_w_ket</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_w_ket([T=ComplexF64,] N::Integer = 3; coeff = 1/√N)</code></pre><p>Produces the ket of the <code>N</code>-partite W state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L134-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_w"><a class="docstring-binding" href="#Ket.state_w"><code>Ket.state_w</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_w([T=ComplexF64,] N::Integer = 3; v::Real = 1, coeff = 1/√N)</code></pre><p>Produces the <code>N</code>-partite W state with visibility <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L147-L151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_dicke_ket"><a class="docstring-binding" href="#Ket.state_dicke_ket"><code>Ket.state_dicke_ket</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_dicke_ket([T=ComplexF64,] N::Integer, k::Integer; coeff = 1/√Cᴺₖ)</code></pre><p>Produces the ket of the <code>N</code>-partite Dicke state with <code>k</code> excitations.</p><p>Reference: Robert H. Dicke <a href="https://doi.org/10.1103/PhysRev.93.99">doi:10.1103/PhysRev.93.99</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L200-L206">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_dicke"><a class="docstring-binding" href="#Ket.state_dicke"><code>Ket.state_dicke</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_dicke([T=ComplexF64,] N::Integer, k::Integer; v::Real = 1)</code></pre><p>Produces the <code>N</code>-partite Dicke state with <code>k</code> excitations.</p><p>Reference: Robert H. Dicke <a href="https://doi.org/10.1103/PhysRev.93.99">doi:10.1103/PhysRev.93.99</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L222-L228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_horodecki33"><a class="docstring-binding" href="#Ket.state_horodecki33"><code>Ket.state_horodecki33</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_horodecki33([T=ComplexF64,] a::Real)</code></pre><p>Produces the 3 × 3 bipartite PPT-entangled Horodecki state with parameter <code>a</code>.</p><p>Reference: Paweł Horodecki, <a href="https://arxiv.org/abs/quant-ph/9703004">arXiv:quant-ph/9703004</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L237-L243">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_horodecki24"><a class="docstring-binding" href="#Ket.state_horodecki24"><code>Ket.state_horodecki24</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_horodecki24([T=ComplexF64,] b::Real)</code></pre><p>Produces the 2 × 4 bipartite PPT-entangled Horodecki state with parameter <code>b</code>.</p><p>Reference: Paweł Horodecki, <a href="https://arxiv.org/abs/quant-ph/9703004">arXiv:quant-ph/9703004</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L265-L271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_grid"><a class="docstring-binding" href="#Ket.state_grid"><code>Ket.state_grid</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_grid([T=ComplexF64], dA::Integer, dB::Integer, edges::Vector{Vector{ntuple{2, Int}}}; weights::Vector{T} = ones(T, length(edges)))</code></pre><p>Produces the bipartite <code>dA</code> × <code>dB</code> grid state according to the <code>dA</code> × <code>dB</code> 2D (hyper-)graph with <code>edges</code> and <code>weights</code>.</p><p>Reference:</p><ul><li>Lockhart et al., <a href="http://arxiv.org/abs/1705.09261">arXiv:1705.09261</a></li><li>Ghimire et al., <a href="https://arxiv.org/abs/2207.09826">arXiv:2207.09826</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L292-L300">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_crosshatch"><a class="docstring-binding" href="#Ket.state_crosshatch"><code>Ket.state_crosshatch</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_crosshatch([T=ComplexF64])</code></pre><p>Produces a bound entangled bipartite 3 × 3 crosshatch state.</p><p>Reference: Lockhart et al., <a href="http://arxiv.org/abs/1705.09261">arXiv:1705.09261</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L316-L322">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_sindici_piani_ket"><a class="docstring-binding" href="#Ket.state_sindici_piani_ket"><code>Ket.state_sindici_piani_ket</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_sindici_piani_ket([T=ComplexF64], d::Integer, k::Integer = 1, l::Integer = d; coeff = inv(_sqrt(T, 2)))</code></pre><p>Produces the ket of Sindici-Piani state of even local dimensions <code>d</code> × <code>d</code></p><p>Reference: Sindici and Piani, <a href="http://arxiv.org/abs/1708.06595">arXiv:1708.06595</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L331-L337">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.state_sindici_piani"><a class="docstring-binding" href="#Ket.state_sindici_piani"><code>Ket.state_sindici_piani</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">state_sindici_piani([T=ComplexF64], d::Integer; coeffs = [√2/√d, ⋯, √2/√d])</code></pre><p>Produces the Sindici-Piani state of even local dimensions <code>d</code> × <code>d</code> with visibility <code>v</code>.</p><p>Reference: Sindici and Piani, <a href="http://arxiv.org/abs/1708.06595">arXiv:1708.06595</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L354-L360">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.white_noise"><a class="docstring-binding" href="#Ket.white_noise"><code>Ket.white_noise</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">white_noise(ρ::AbstractMatrix, v::Real)</code></pre><p>Returns <code>v * ρ + (1 - v) * id</code>, where <code>id</code> is the maximally mixed state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket.white_noise!"><a class="docstring-binding" href="#Ket.white_noise!"><code>Ket.white_noise!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">white_noise!(ρ::AbstractMatrix, v::Real)</code></pre><p>Modifies <code>ρ</code> in place to tranform it into <code>v * rho + (1 - v) * id</code> where <code>id</code> is the maximally mixed state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/states.jl#L11-L16">source</a></section></details></article><h2 id="Internal-functions"><a class="docs-heading-anchor" href="#Internal-functions">Internal functions</a><a id="Internal-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Ket._dps_constraints!"><a class="docstring-binding" href="#Ket._dps_constraints!"><code>Ket._dps_constraints!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_dps_constraints!(model::JuMP.GenericModel, ρ::AbstractMatrix, dims::AbstractVector, n::Integer; ppt::Bool = true, is_complex::Bool = true, isometry::AbstractMatrix = I(size(ρ, 1)))</code></pre><p>Constrains state <code>ρ</code> of dimensions <code>dims</code> in JuMP model <code>model</code> to respect the DPS constraints of level <code>n</code>. Dimensions are specified in <code>dims = [dA, dB]</code> and the extensions will be done on the second subsystem. The extensions can be symmetric real matrices (<code>is_complex = false</code>) or Hermitian PSD. With <code>ppt = true</code>, PPT constraints are enforced for transposed subsystems 2:i, for i ∈ 2:n+1. Use <code>isometry</code> to specify a <span>$V$</span> to be applied in the constraint <span>$ρ = V&#39; * tr_{B_2 ... B_n}(Ξ) V$</span>.</p><p>Reference: Doherty, Parrilo, Spedalieri, <a href="https://arxiv.org/abs/quant-ph/0308032">arXiv:quant-ph/0308032</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/entanglement.jl#L262-L272">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket._inner_dps_constraints!"><a class="docstring-binding" href="#Ket._inner_dps_constraints!"><code>Ket._inner_dps_constraints!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_inner_dps_constraints!(model::JuMP.GenericModel, ρ::AbstractMatrix, dims::AbstractVector, n::Integer; ppt::Bool = true, is_complex::Bool = true, isometry::AbstractMatrix = I(size(ρ, 1)))</code></pre><p>Constrains state <code>ρ</code> of dimensions <code>dims</code> in JuMP model <code>model</code> to respect the Inner DPS constraints of level <code>n</code>. Dimensions are specified in <code>dims = [dA, dB]</code> and the extensions will be done on the second subsystem. The extensions can be symmetric real matrices (<code>is_complex = false</code>) or Hermitian PSD. With <code>ppt = true</code>, the extended part is constrained to be PPT for the [1:⌈n/2⌉+1, rest] partition.</p><p>References: Navascués, Owari, Plenio <a href="https://arxiv.org/abs/0906.2735">arXiv:0906.2735</a> and <a href="https://arxiv.org/abs/0906.2731">arXiv:0906.2731</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/entanglement.jl#L351-L360">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket._partition"><a class="docstring-binding" href="#Ket._partition"><code>Ket._partition</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">partition(n::Integer, k::Integer)</code></pre><p>If <code>n ≥ k</code> partitions the set <code>1:n</code> into <code>k</code> parts as equally sized as possible. Otherwise partitions it into <code>n</code> parts of size 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/nonlocal.jl#L203-L208">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Ket._fiducial_WH"><a class="docstring-binding" href="#Ket._fiducial_WH"><code>Ket._fiducial_WH</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_fiducial_WH([T=ComplexF64,] d::Integer)</code></pre><p>Computes the fiducial Weyl-Heisenberg vector of dimension <code>d</code>.</p><p>References:</p><ul><li>Appleby, Yadsan-Appleby, Zauner, <a href="http://arxiv.org/abs/1209.1813">arXiv:1209.1813</a></li><li><a href="http://www.gerhardzauner.at/sicfiducials.html">www.gerhardzauner.at/sicfiducials.html</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dev-ket/Ket.jl/blob/ec795f997fb10219ecf9032dbbd99f842e55b46c/src/sic-povm.jl#L49-L57">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting started</a><a class="docs-footer-nextpage" href="../examples/tilted_chsh/">Tilted CHSH inequality »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 2 December 2025 02:14">Tuesday 2 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
